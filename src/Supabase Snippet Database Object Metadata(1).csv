"object_type","schema_name","object_name","sub_object_name","definition","additional_info"
"AGGREGATE","pgsodium","crypto_sign_update_agg","null","AGGREGATE FUNCTION","Multi-part message signing aggregate that returns a state which can
then be finalised using crypto_sign_final() or to which other parts
can be added crypto_sign_update() or another message signing aggregate
function.

Note that when signing mutli-part messages using aggregates, the order
in which message parts is processed is critical. You *must* ensure
that the order of messages passed to the aggregate is invariant."
"AGGREGATE","pgsodium","crypto_sign_update_agg","null","AGGREGATE FUNCTION","Multi-part message signing aggregate that returns a state which can
then be finalised using crypto_sign_final() or to which other parts
can be added crypto_sign_update() or another message signing aggregate
function.

The first argument to this aggregate is the input state. This may be
the result of a previous crypto_sign_update_agg(), a previous
crypto_sign_update().

Note that when signing mutli-part messages using aggregates, the order
in which message parts is processed is critical. You *must* ensure
that the order of messages passed to the aggregate is invariant."
"COLUMN","auth","audit_log_entries","created_at","timestamp with time zone","null"
"COLUMN","auth","audit_log_entries","id","uuid NOT NULL","null"
"COLUMN","auth","audit_log_entries","instance_id","uuid","null"
"COLUMN","auth","audit_log_entries","ip_address","character varying(64) NOT NULL DEFAULT ''::character varying","null"
"COLUMN","auth","audit_log_entries","payload","json","null"
"COLUMN","auth","flow_state","auth_code","text NOT NULL","null"
"COLUMN","auth","flow_state","auth_code_issued_at","timestamp with time zone","null"
"COLUMN","auth","flow_state","authentication_method","text NOT NULL","null"
"COLUMN","auth","flow_state","code_challenge","text NOT NULL","null"
"COLUMN","auth","flow_state","code_challenge_method","auth.code_challenge_method NOT NULL","null"
"COLUMN","auth","flow_state","created_at","timestamp with time zone","null"
"COLUMN","auth","flow_state","id","uuid NOT NULL","null"
"COLUMN","auth","flow_state","provider_access_token","text","null"
"COLUMN","auth","flow_state","provider_refresh_token","text","null"
"COLUMN","auth","flow_state","provider_type","text NOT NULL","null"
"COLUMN","auth","flow_state","updated_at","timestamp with time zone","null"
"COLUMN","auth","flow_state","user_id","uuid","null"
"COLUMN","auth","identities","created_at","timestamp with time zone","null"
"COLUMN","auth","identities","email","text DEFAULT lower((identity_data ->> 'email'::text))","Auth: Email is a generated column that references the optional email property in the identity_data"
"COLUMN","auth","identities","id","uuid NOT NULL DEFAULT gen_random_uuid()","null"
"COLUMN","auth","identities","identity_data","jsonb NOT NULL","null"
"COLUMN","auth","identities","last_sign_in_at","timestamp with time zone","null"
"COLUMN","auth","identities","provider","text NOT NULL","null"
"COLUMN","auth","identities","provider_id","text NOT NULL","null"
"COLUMN","auth","identities","updated_at","timestamp with time zone","null"
"COLUMN","auth","identities","user_id","uuid NOT NULL","null"
"COLUMN","auth","instances","created_at","timestamp with time zone","null"
"COLUMN","auth","instances","id","uuid NOT NULL","null"
"COLUMN","auth","instances","raw_base_config","text","null"
"COLUMN","auth","instances","updated_at","timestamp with time zone","null"
"COLUMN","auth","instances","uuid","uuid","null"
"COLUMN","auth","mfa_amr_claims","authentication_method","text NOT NULL","null"
"COLUMN","auth","mfa_amr_claims","created_at","timestamp with time zone NOT NULL","null"
"COLUMN","auth","mfa_amr_claims","id","uuid NOT NULL","null"
"COLUMN","auth","mfa_amr_claims","session_id","uuid NOT NULL","null"
"COLUMN","auth","mfa_amr_claims","updated_at","timestamp with time zone NOT NULL","null"
"COLUMN","auth","mfa_challenges","created_at","timestamp with time zone NOT NULL","null"
"COLUMN","auth","mfa_challenges","factor_id","uuid NOT NULL","null"
"COLUMN","auth","mfa_challenges","id","uuid NOT NULL","null"
"COLUMN","auth","mfa_challenges","ip_address","inet NOT NULL","null"
"COLUMN","auth","mfa_challenges","otp_code","text","null"
"COLUMN","auth","mfa_challenges","verified_at","timestamp with time zone","null"
"COLUMN","auth","mfa_challenges","web_authn_session_data","jsonb","null"
"COLUMN","auth","mfa_factors","created_at","timestamp with time zone NOT NULL","null"
"COLUMN","auth","mfa_factors","factor_type","auth.factor_type NOT NULL","null"
"COLUMN","auth","mfa_factors","friendly_name","text","null"
"COLUMN","auth","mfa_factors","id","uuid NOT NULL","null"
"COLUMN","auth","mfa_factors","last_challenged_at","timestamp with time zone","null"
"COLUMN","auth","mfa_factors","phone","text","null"
"COLUMN","auth","mfa_factors","secret","text","null"
"COLUMN","auth","mfa_factors","status","auth.factor_status NOT NULL","null"
"COLUMN","auth","mfa_factors","updated_at","timestamp with time zone NOT NULL","null"
"COLUMN","auth","mfa_factors","user_id","uuid NOT NULL","null"
"COLUMN","auth","mfa_factors","web_authn_aaguid","uuid","null"
"COLUMN","auth","mfa_factors","web_authn_credential","jsonb","null"
"COLUMN","auth","one_time_tokens","created_at","timestamp without time zone NOT NULL DEFAULT now()","null"
"COLUMN","auth","one_time_tokens","id","uuid NOT NULL","null"
"COLUMN","auth","one_time_tokens","relates_to","text NOT NULL","null"
"COLUMN","auth","one_time_tokens","token_hash","text NOT NULL","null"
"COLUMN","auth","one_time_tokens","token_type","auth.one_time_token_type NOT NULL","null"
"COLUMN","auth","one_time_tokens","updated_at","timestamp without time zone NOT NULL DEFAULT now()","null"
"COLUMN","auth","one_time_tokens","user_id","uuid NOT NULL","null"
"COLUMN","auth","refresh_tokens","created_at","timestamp with time zone","null"
"COLUMN","auth","refresh_tokens","id","bigint NOT NULL DEFAULT nextval('auth.refresh_tokens_id_seq'::regclass)","null"
"COLUMN","auth","refresh_tokens","instance_id","uuid","null"
"COLUMN","auth","refresh_tokens","parent","character varying(255)","null"
"COLUMN","auth","refresh_tokens","revoked","boolean","null"
"COLUMN","auth","refresh_tokens","session_id","uuid","null"
"COLUMN","auth","refresh_tokens","token","character varying(255)","null"
"COLUMN","auth","refresh_tokens","updated_at","timestamp with time zone","null"
"COLUMN","auth","refresh_tokens","user_id","character varying(255)","null"
"COLUMN","auth","saml_providers","attribute_mapping","jsonb","null"
"COLUMN","auth","saml_providers","created_at","timestamp with time zone","null"
"COLUMN","auth","saml_providers","entity_id","text NOT NULL","null"
"COLUMN","auth","saml_providers","id","uuid NOT NULL","null"
"COLUMN","auth","saml_providers","metadata_url","text","null"
"COLUMN","auth","saml_providers","metadata_xml","text NOT NULL","null"
"COLUMN","auth","saml_providers","name_id_format","text","null"
"COLUMN","auth","saml_providers","sso_provider_id","uuid NOT NULL","null"
"COLUMN","auth","saml_providers","updated_at","timestamp with time zone","null"
"COLUMN","auth","saml_relay_states","created_at","timestamp with time zone","null"
"COLUMN","auth","saml_relay_states","flow_state_id","uuid","null"
"COLUMN","auth","saml_relay_states","for_email","text","null"
"COLUMN","auth","saml_relay_states","id","uuid NOT NULL","null"
"COLUMN","auth","saml_relay_states","redirect_to","text","null"
"COLUMN","auth","saml_relay_states","request_id","text NOT NULL","null"
"COLUMN","auth","saml_relay_states","sso_provider_id","uuid NOT NULL","null"
"COLUMN","auth","saml_relay_states","updated_at","timestamp with time zone","null"
"COLUMN","auth","schema_migrations","version","character varying(255) NOT NULL","null"
"COLUMN","auth","sessions","aal","auth.aal_level","null"
"COLUMN","auth","sessions","created_at","timestamp with time zone","null"
"COLUMN","auth","sessions","factor_id","uuid","null"
"COLUMN","auth","sessions","id","uuid NOT NULL","null"
"COLUMN","auth","sessions","ip","inet","null"
"COLUMN","auth","sessions","not_after","timestamp with time zone","Auth: Not after is a nullable column that contains a timestamp after which the session should be regarded as expired."
"COLUMN","auth","sessions","refreshed_at","timestamp without time zone","null"
"COLUMN","auth","sessions","tag","text","null"
"COLUMN","auth","sessions","updated_at","timestamp with time zone","null"
"COLUMN","auth","sessions","user_agent","text","null"
"COLUMN","auth","sessions","user_id","uuid NOT NULL","null"
"COLUMN","auth","sso_domains","created_at","timestamp with time zone","null"
"COLUMN","auth","sso_domains","domain","text NOT NULL","null"
"COLUMN","auth","sso_domains","id","uuid NOT NULL","null"
"COLUMN","auth","sso_domains","sso_provider_id","uuid NOT NULL","null"
"COLUMN","auth","sso_domains","updated_at","timestamp with time zone","null"
"COLUMN","auth","sso_providers","created_at","timestamp with time zone","null"
"COLUMN","auth","sso_providers","id","uuid NOT NULL","null"
"COLUMN","auth","sso_providers","resource_id","text","Auth: Uniquely identifies a SSO provider according to a user-chosen resource ID (case insensitive), useful in infrastructure as code."
"COLUMN","auth","sso_providers","updated_at","timestamp with time zone","null"
"COLUMN","auth","users","aud","character varying(255)","null"
"COLUMN","auth","users","banned_until","timestamp with time zone","null"
"COLUMN","auth","users","confirmation_sent_at","timestamp with time zone","null"
"COLUMN","auth","users","confirmation_token","character varying(255)","null"
"COLUMN","auth","users","confirmed_at","timestamp with time zone DEFAULT LEAST(email_confirmed_at, phone_confirmed_at)","null"
"COLUMN","auth","users","created_at","timestamp with time zone","null"
"COLUMN","auth","users","deleted_at","timestamp with time zone","null"
"COLUMN","auth","users","email","character varying(255)","null"
"COLUMN","auth","users","email_change","character varying(255)","null"
"COLUMN","auth","users","email_change_confirm_status","smallint DEFAULT 0","null"
"COLUMN","auth","users","email_change_sent_at","timestamp with time zone","null"
"COLUMN","auth","users","email_change_token_current","character varying(255) DEFAULT ''::character varying","null"
"COLUMN","auth","users","email_change_token_new","character varying(255)","null"
"COLUMN","auth","users","email_confirmed_at","timestamp with time zone","null"
"COLUMN","auth","users","encrypted_password","character varying(255)","null"
"COLUMN","auth","users","id","uuid NOT NULL","null"
"COLUMN","auth","users","instance_id","uuid","null"
"COLUMN","auth","users","invited_at","timestamp with time zone","null"
"COLUMN","auth","users","is_anonymous","boolean NOT NULL DEFAULT false","null"
"COLUMN","auth","users","is_sso_user","boolean NOT NULL DEFAULT false","Auth: Set this column to true when the account comes from SSO. These accounts can have duplicate emails."
"COLUMN","auth","users","is_super_admin","boolean","null"
"COLUMN","auth","users","last_sign_in_at","timestamp with time zone","null"
"COLUMN","auth","users","phone","text DEFAULT NULL::character varying","null"
"COLUMN","auth","users","phone_change","text DEFAULT ''::character varying","null"
"COLUMN","auth","users","phone_change_sent_at","timestamp with time zone","null"
"COLUMN","auth","users","phone_change_token","character varying(255) DEFAULT ''::character varying","null"
"COLUMN","auth","users","phone_confirmed_at","timestamp with time zone","null"
"COLUMN","auth","users","raw_app_meta_data","jsonb","null"
"COLUMN","auth","users","raw_user_meta_data","jsonb","null"
"COLUMN","auth","users","reauthentication_sent_at","timestamp with time zone","null"
"COLUMN","auth","users","reauthentication_token","character varying(255) DEFAULT ''::character varying","null"
"COLUMN","auth","users","recovery_sent_at","timestamp with time zone","null"
"COLUMN","auth","users","recovery_token","character varying(255)","null"
"COLUMN","auth","users","role","character varying(255)","null"
"COLUMN","auth","users","updated_at","timestamp with time zone","null"
"COLUMN","pgsodium","key","associated_data","text DEFAULT 'associated'::text","null"
"COLUMN","pgsodium","key","comment","text","null"
"COLUMN","pgsodium","key","created","timestamp with time zone NOT NULL DEFAULT CURRENT_TIMESTAMP","null"
"COLUMN","pgsodium","key","expires","timestamp with time zone","null"
"COLUMN","pgsodium","key","id","uuid NOT NULL DEFAULT gen_random_uuid()","null"
"COLUMN","pgsodium","key","key_context","bytea DEFAULT '\x7067736f6469756d'::bytea","null"
"COLUMN","pgsodium","key","key_id","bigint DEFAULT nextval('pgsodium.key_key_id_seq'::regclass)","null"
"COLUMN","pgsodium","key","key_type","pgsodium.key_type","null"
"COLUMN","pgsodium","key","name","text","null"
"COLUMN","pgsodium","key","parent_key","uuid","null"
"COLUMN","pgsodium","key","raw_key","bytea","null"
"COLUMN","pgsodium","key","raw_key_nonce","bytea","null"
"COLUMN","pgsodium","key","status","pgsodium.key_status DEFAULT 'valid'::pgsodium.key_status","null"
"COLUMN","pgsodium","key","user_data","text","null"
"COLUMN","public","comment_votes","comment_id","uuid NOT NULL","null"
"COLUMN","public","comment_votes","created_at","timestamp with time zone DEFAULT now()","null"
"COLUMN","public","comment_votes","id","uuid NOT NULL DEFAULT uuid_generate_v4()","null"
"COLUMN","public","comment_votes","user_id","uuid NOT NULL","null"
"COLUMN","public","comment_votes","vote_type","vote_type NOT NULL","null"
"COLUMN","public","comments","content","text NOT NULL","null"
"COLUMN","public","comments","created_at","timestamp with time zone DEFAULT now()","null"
"COLUMN","public","comments","id","uuid NOT NULL DEFAULT uuid_generate_v4()","null"
"COLUMN","public","comments","parent_id","uuid","null"
"COLUMN","public","comments","post_id","uuid NOT NULL","null"
"COLUMN","public","comments","updated_at","timestamp with time zone DEFAULT now()","null"
"COLUMN","public","comments","user_id","uuid NOT NULL","null"
"COLUMN","public","conversation_participants","conversation_id","uuid NOT NULL","null"
"COLUMN","public","conversation_participants","created_at","timestamp with time zone DEFAULT now()","null"
"COLUMN","public","conversation_participants","id","uuid NOT NULL DEFAULT uuid_generate_v4()","null"
"COLUMN","public","conversation_participants","user_id","uuid NOT NULL","null"
"COLUMN","public","conversations","created_at","timestamp with time zone DEFAULT now()","null"
"COLUMN","public","conversations","id","uuid NOT NULL DEFAULT uuid_generate_v4()","null"
"COLUMN","public","conversations","is_group","boolean DEFAULT false","null"
"COLUMN","public","conversations","name","character varying(100)","null"
"COLUMN","public","conversations","updated_at","timestamp with time zone DEFAULT now()","null"
"COLUMN","public","friendships","created_at","timestamp with time zone DEFAULT now()","null"
"COLUMN","public","friendships","friend_id","uuid NOT NULL","null"
"COLUMN","public","friendships","id","uuid NOT NULL DEFAULT uuid_generate_v4()","null"
"COLUMN","public","friendships","status","friendship_status DEFAULT 'pending'::friendship_status","null"
"COLUMN","public","friendships","updated_at","timestamp with time zone DEFAULT now()","null"
"COLUMN","public","friendships","user_id","uuid NOT NULL","null"
"COLUMN","public","group_members","created_at","timestamp with time zone DEFAULT now()","null"
"COLUMN","public","group_members","group_id","uuid NOT NULL","null"
"COLUMN","public","group_members","id","uuid NOT NULL DEFAULT uuid_generate_v4()","null"
"COLUMN","public","group_members","role","member_role DEFAULT 'member'::member_role","null"
"COLUMN","public","group_members","user_id","uuid NOT NULL","null"
"COLUMN","public","groups","created_at","timestamp with time zone DEFAULT now()","null"
"COLUMN","public","groups","description","text","null"
"COLUMN","public","groups","id","uuid NOT NULL DEFAULT uuid_generate_v4()","null"
"COLUMN","public","groups","name","character varying(100) NOT NULL","null"
"COLUMN","public","groups","privacy","group_privacy DEFAULT 'public'::group_privacy","null"
"COLUMN","public","groups","updated_at","timestamp with time zone DEFAULT now()","null"
"COLUMN","public","likes","comment_id","uuid","null"
"COLUMN","public","likes","created_at","timestamp with time zone DEFAULT now()","null"
"COLUMN","public","likes","id","uuid NOT NULL DEFAULT uuid_generate_v4()","null"
"COLUMN","public","likes","post_id","uuid","null"
"COLUMN","public","likes","user_id","uuid NOT NULL","null"
"COLUMN","public","media","created_at","timestamp with time zone DEFAULT now()","null"
"COLUMN","public","media","id","uuid NOT NULL DEFAULT uuid_generate_v4()","null"
"COLUMN","public","media","media_type","media_type NOT NULL","null"
"COLUMN","public","media","message_id","uuid","null"
"COLUMN","public","media","order_index","integer DEFAULT 0","null"
"COLUMN","public","media","post_id","uuid","null"
"COLUMN","public","media","url","text NOT NULL","null"
"COLUMN","public","messages","content","text NOT NULL","null"
"COLUMN","public","messages","conversation_id","uuid NOT NULL","null"
"COLUMN","public","messages","created_at","timestamp with time zone DEFAULT now()","null"
"COLUMN","public","messages","id","uuid NOT NULL DEFAULT uuid_generate_v4()","null"
"COLUMN","public","messages","read","boolean DEFAULT false","null"
"COLUMN","public","messages","user_id","uuid NOT NULL","null"
"COLUMN","public","notifications","actor_id","uuid NOT NULL","null"
"COLUMN","public","notifications","content","text NOT NULL","null"
"COLUMN","public","notifications","created_at","timestamp with time zone DEFAULT now()","null"
"COLUMN","public","notifications","icon","text","null"
"COLUMN","public","notifications","id","uuid NOT NULL DEFAULT uuid_generate_v4()","null"
"COLUMN","public","notifications","read","boolean DEFAULT false","null"
"COLUMN","public","notifications","resource_id","uuid NOT NULL","null"
"COLUMN","public","notifications","resource_type","character varying(50) NOT NULL","null"
"COLUMN","public","notifications","type","notification_type NOT NULL","null"
"COLUMN","public","notifications","user_id","uuid NOT NULL","null"
"COLUMN","public","posts","content","text","null"
"COLUMN","public","posts","created_at","timestamp with time zone DEFAULT now()","null"
"COLUMN","public","posts","group_id","uuid","null"
"COLUMN","public","posts","id","uuid NOT NULL DEFAULT uuid_generate_v4()","null"
"COLUMN","public","posts","privacy_level","privacy_level DEFAULT 'public'::privacy_level","null"
"COLUMN","public","posts","search_vector","tsvector","null"
"COLUMN","public","posts","updated_at","timestamp with time zone DEFAULT now()","null"
"COLUMN","public","posts","user_id","uuid NOT NULL","null"
"COLUMN","public","user_hidden_posts","hidden_at","timestamp with time zone DEFAULT now()","null"
"COLUMN","public","user_hidden_posts","post_id","uuid NOT NULL","null"
"COLUMN","public","user_hidden_posts","user_id","uuid NOT NULL","null"
"COLUMN","public","user_saved_posts","post_id","uuid NOT NULL","null"
"COLUMN","public","user_saved_posts","saved_at","timestamp with time zone DEFAULT now()","null"
"COLUMN","public","user_saved_posts","user_id","uuid NOT NULL","null"
"COLUMN","public","users","avatar_url","text","null"
"COLUMN","public","users","bio","text","null"
"COLUMN","public","users","created_at","timestamp with time zone DEFAULT now()","null"
"COLUMN","public","users","email","character varying(255) NOT NULL","null"
"COLUMN","public","users","full_name","character varying(100) NOT NULL","null"
"COLUMN","public","users","id","uuid NOT NULL DEFAULT uuid_generate_v4()","null"
"COLUMN","public","users","privacy_settings","jsonb DEFAULT '{"posts_visibility": "public", "profile_visibility": "public"}'::jsonb","null"
"COLUMN","public","users","theme","theme_option DEFAULT 'light'::theme_option","null"
"COLUMN","public","users","updated_at","timestamp with time zone DEFAULT now()","null"
"COLUMN","public","users","username","character varying(50) NOT NULL","null"
"COLUMN","realtime","schema_migrations","inserted_at","timestamp(0) without time zone","null"
"COLUMN","realtime","schema_migrations","version","bigint NOT NULL","null"
"COLUMN","realtime","subscription","claims","jsonb NOT NULL","null"
"COLUMN","realtime","subscription","claims_role","regrole NOT NULL DEFAULT realtime.to_regrole((claims ->> 'role'::text))","null"
"COLUMN","realtime","subscription","created_at","timestamp without time zone NOT NULL DEFAULT timezone('utc'::text, now())","null"
"COLUMN","realtime","subscription","entity","regclass NOT NULL","null"
"COLUMN","realtime","subscription","filters","realtime.user_defined_filter[] NOT NULL DEFAULT '{}'::realtime.user_defined_filter[]","null"
"COLUMN","realtime","subscription","id","bigint NOT NULL","null"
"COLUMN","realtime","subscription","subscription_id","uuid NOT NULL","null"
"COLUMN","storage","buckets","allowed_mime_types","text[]","null"
"COLUMN","storage","buckets","avif_autodetection","boolean DEFAULT false","null"
"COLUMN","storage","buckets","created_at","timestamp with time zone DEFAULT now()","null"
"COLUMN","storage","buckets","file_size_limit","bigint","null"
"COLUMN","storage","buckets","id","text NOT NULL","null"
"COLUMN","storage","buckets","name","text NOT NULL","null"
"COLUMN","storage","buckets","owner","uuid","Field is deprecated, use owner_id instead"
"COLUMN","storage","buckets","owner_id","text","null"
"COLUMN","storage","buckets","public","boolean DEFAULT false","null"
"COLUMN","storage","buckets","updated_at","timestamp with time zone DEFAULT now()","null"
"COLUMN","storage","migrations","executed_at","timestamp without time zone DEFAULT CURRENT_TIMESTAMP","null"
"COLUMN","storage","migrations","hash","character varying(40) NOT NULL","null"
"COLUMN","storage","migrations","id","integer NOT NULL","null"
"COLUMN","storage","migrations","name","character varying(100) NOT NULL","null"
"COLUMN","storage","objects","bucket_id","text","null"
"COLUMN","storage","objects","created_at","timestamp with time zone DEFAULT now()","null"
"COLUMN","storage","objects","id","uuid NOT NULL DEFAULT gen_random_uuid()","null"
"COLUMN","storage","objects","last_accessed_at","timestamp with time zone DEFAULT now()","null"
"COLUMN","storage","objects","metadata","jsonb","null"
"COLUMN","storage","objects","name","text","null"
"COLUMN","storage","objects","owner","uuid","Field is deprecated, use owner_id instead"
"COLUMN","storage","objects","owner_id","text","null"
"COLUMN","storage","objects","path_tokens","text[] DEFAULT string_to_array(name, '/'::text)","null"
"COLUMN","storage","objects","updated_at","timestamp with time zone DEFAULT now()","null"
"COLUMN","storage","objects","user_metadata","jsonb","null"
"COLUMN","storage","objects","version","text","null"
"COLUMN","storage","s3_multipart_uploads","bucket_id","text NOT NULL","null"
"COLUMN","storage","s3_multipart_uploads","created_at","timestamp with time zone NOT NULL DEFAULT now()","null"
"COLUMN","storage","s3_multipart_uploads","id","text NOT NULL","null"
"COLUMN","storage","s3_multipart_uploads","in_progress_size","bigint NOT NULL DEFAULT 0","null"
"COLUMN","storage","s3_multipart_uploads","key","text NOT NULL","null"
"COLUMN","storage","s3_multipart_uploads","owner_id","text","null"
"COLUMN","storage","s3_multipart_uploads","upload_signature","text NOT NULL","null"
"COLUMN","storage","s3_multipart_uploads","user_metadata","jsonb","null"
"COLUMN","storage","s3_multipart_uploads","version","text NOT NULL","null"
"COLUMN","storage","s3_multipart_uploads_parts","bucket_id","text NOT NULL","null"
"COLUMN","storage","s3_multipart_uploads_parts","created_at","timestamp with time zone NOT NULL DEFAULT now()","null"
"COLUMN","storage","s3_multipart_uploads_parts","etag","text NOT NULL","null"
"COLUMN","storage","s3_multipart_uploads_parts","id","uuid NOT NULL DEFAULT gen_random_uuid()","null"
"COLUMN","storage","s3_multipart_uploads_parts","key","text NOT NULL","null"
"COLUMN","storage","s3_multipart_uploads_parts","owner_id","text","null"
"COLUMN","storage","s3_multipart_uploads_parts","part_number","integer NOT NULL","null"
"COLUMN","storage","s3_multipart_uploads_parts","size","bigint NOT NULL DEFAULT 0","null"
"COLUMN","storage","s3_multipart_uploads_parts","upload_id","text NOT NULL","null"
"COLUMN","storage","s3_multipart_uploads_parts","version","text NOT NULL","null"
"COLUMN","vault","secrets","created_at","timestamp with time zone NOT NULL DEFAULT CURRENT_TIMESTAMP","null"
"COLUMN","vault","secrets","description","text NOT NULL DEFAULT ''::text","null"
"COLUMN","vault","secrets","id","uuid NOT NULL DEFAULT gen_random_uuid()","null"
"COLUMN","vault","secrets","key_id","uuid DEFAULT (pgsodium.create_key()).id","null"
"COLUMN","vault","secrets","name","text","null"
"COLUMN","vault","secrets","nonce","bytea DEFAULT pgsodium.crypto_aead_det_noncegen()","null"
"COLUMN","vault","secrets","secret","text NOT NULL","null"
"COLUMN","vault","secrets","updated_at","timestamp with time zone NOT NULL DEFAULT CURRENT_TIMESTAMP","null"
"CONSTRAINT","auth","audit_log_entries","audit_log_entries_pkey","PRIMARY KEY (id)","PRIMARY KEY"
"CONSTRAINT","auth","flow_state","flow_state_pkey","PRIMARY KEY (id)","PRIMARY KEY"
"CONSTRAINT","auth","identities","identities_pkey","PRIMARY KEY (id)","PRIMARY KEY"
"CONSTRAINT","auth","identities","identities_provider_id_provider_unique","UNIQUE (provider_id, provider)","UNIQUE"
"CONSTRAINT","auth","identities","identities_user_id_fkey","FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","auth","instances","instances_pkey","PRIMARY KEY (id)","PRIMARY KEY"
"CONSTRAINT","auth","mfa_amr_claims","amr_id_pk","PRIMARY KEY (id)","PRIMARY KEY"
"CONSTRAINT","auth","mfa_amr_claims","mfa_amr_claims_session_id_authentication_method_pkey","UNIQUE (session_id, authentication_method)","UNIQUE"
"CONSTRAINT","auth","mfa_amr_claims","mfa_amr_claims_session_id_fkey","FOREIGN KEY (session_id) REFERENCES auth.sessions(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","auth","mfa_challenges","mfa_challenges_auth_factor_id_fkey","FOREIGN KEY (factor_id) REFERENCES auth.mfa_factors(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","auth","mfa_challenges","mfa_challenges_pkey","PRIMARY KEY (id)","PRIMARY KEY"
"CONSTRAINT","auth","mfa_factors","mfa_factors_last_challenged_at_key","UNIQUE (last_challenged_at)","UNIQUE"
"CONSTRAINT","auth","mfa_factors","mfa_factors_pkey","PRIMARY KEY (id)","PRIMARY KEY"
"CONSTRAINT","auth","mfa_factors","mfa_factors_user_id_fkey","FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","auth","one_time_tokens","one_time_tokens_pkey","PRIMARY KEY (id)","PRIMARY KEY"
"CONSTRAINT","auth","one_time_tokens","one_time_tokens_token_hash_check","CHECK ((char_length(token_hash) > 0))","CHECK"
"CONSTRAINT","auth","one_time_tokens","one_time_tokens_user_id_fkey","FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","auth","refresh_tokens","refresh_tokens_pkey","PRIMARY KEY (id)","PRIMARY KEY"
"CONSTRAINT","auth","refresh_tokens","refresh_tokens_session_id_fkey","FOREIGN KEY (session_id) REFERENCES auth.sessions(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","auth","refresh_tokens","refresh_tokens_token_unique","UNIQUE (token)","UNIQUE"
"CONSTRAINT","auth","saml_providers","entity_id not empty","CHECK ((char_length(entity_id) > 0))","CHECK"
"CONSTRAINT","auth","saml_providers","metadata_url not empty","CHECK (((metadata_url = NULL::text) OR (char_length(metadata_url) > 0)))","CHECK"
"CONSTRAINT","auth","saml_providers","metadata_xml not empty","CHECK ((char_length(metadata_xml) > 0))","CHECK"
"CONSTRAINT","auth","saml_providers","saml_providers_entity_id_key","UNIQUE (entity_id)","UNIQUE"
"CONSTRAINT","auth","saml_providers","saml_providers_pkey","PRIMARY KEY (id)","PRIMARY KEY"
"CONSTRAINT","auth","saml_providers","saml_providers_sso_provider_id_fkey","FOREIGN KEY (sso_provider_id) REFERENCES auth.sso_providers(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","auth","saml_relay_states","request_id not empty","CHECK ((char_length(request_id) > 0))","CHECK"
"CONSTRAINT","auth","saml_relay_states","saml_relay_states_flow_state_id_fkey","FOREIGN KEY (flow_state_id) REFERENCES auth.flow_state(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","auth","saml_relay_states","saml_relay_states_pkey","PRIMARY KEY (id)","PRIMARY KEY"
"CONSTRAINT","auth","saml_relay_states","saml_relay_states_sso_provider_id_fkey","FOREIGN KEY (sso_provider_id) REFERENCES auth.sso_providers(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","auth","schema_migrations","schema_migrations_pkey","PRIMARY KEY (version)","PRIMARY KEY"
"CONSTRAINT","auth","sessions","sessions_pkey","PRIMARY KEY (id)","PRIMARY KEY"
"CONSTRAINT","auth","sessions","sessions_user_id_fkey","FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","auth","sso_domains","domain not empty","CHECK ((char_length(domain) > 0))","CHECK"
"CONSTRAINT","auth","sso_domains","sso_domains_pkey","PRIMARY KEY (id)","PRIMARY KEY"
"CONSTRAINT","auth","sso_domains","sso_domains_sso_provider_id_fkey","FOREIGN KEY (sso_provider_id) REFERENCES auth.sso_providers(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","auth","sso_providers","resource_id not empty","CHECK (((resource_id = NULL::text) OR (char_length(resource_id) > 0)))","CHECK"
"CONSTRAINT","auth","sso_providers","sso_providers_pkey","PRIMARY KEY (id)","PRIMARY KEY"
"CONSTRAINT","auth","users","users_email_change_confirm_status_check","CHECK (((email_change_confirm_status >= 0) AND (email_change_confirm_status <= 2)))","CHECK"
"CONSTRAINT","auth","users","users_phone_key","UNIQUE (phone)","UNIQUE"
"CONSTRAINT","auth","users","users_pkey","PRIMARY KEY (id)","PRIMARY KEY"
"CONSTRAINT","pgsodium","key","key_key_context_check","CHECK ((length(key_context) = 8))","CHECK"
"CONSTRAINT","pgsodium","key","key_parent_key_fkey","FOREIGN KEY (parent_key) REFERENCES pgsodium.key(id)","FOREIGN KEY"
"CONSTRAINT","pgsodium","key","key_pkey","PRIMARY KEY (id)","PRIMARY KEY"
"CONSTRAINT","pgsodium","key","pgsodium_key_unique_name","UNIQUE (name)","UNIQUE"
"CONSTRAINT","pgsodium","key","pgsodium_raw","CHECK (
CASE
    WHEN (raw_key IS NOT NULL) THEN ((key_id IS NULL) AND (key_context IS NULL) AND (parent_key IS NOT NULL))
    ELSE ((key_id IS NOT NULL) AND (key_context IS NOT NULL) AND (parent_key IS NULL))
END)","CHECK"
"CONSTRAINT","public","comment_votes","comment_votes_comment_id_fkey","FOREIGN KEY (comment_id) REFERENCES comments(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","public","comment_votes","comment_votes_pkey","PRIMARY KEY (id)","PRIMARY KEY"
"CONSTRAINT","public","comment_votes","comment_votes_user_comment_unique","UNIQUE (user_id, comment_id)","UNIQUE"
"CONSTRAINT","public","comment_votes","comment_votes_user_id_fkey","FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","public","comments","comments_parent_id_fkey","FOREIGN KEY (parent_id) REFERENCES comments(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","public","comments","comments_pkey","PRIMARY KEY (id)","PRIMARY KEY"
"CONSTRAINT","public","comments","comments_post_id_fkey","FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","public","comments","comments_user_id_fkey","FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","public","conversation_participants","conversation_participants_conversation_id_fkey","FOREIGN KEY (conversation_id) REFERENCES conversations(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","public","conversation_participants","conversation_participants_conversation_id_user_id_key","UNIQUE (conversation_id, user_id)","UNIQUE"
"CONSTRAINT","public","conversation_participants","conversation_participants_pkey","PRIMARY KEY (id)","PRIMARY KEY"
"CONSTRAINT","public","conversation_participants","conversation_participants_user_id_fkey","FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","public","conversations","conversations_pkey","PRIMARY KEY (id)","PRIMARY KEY"
"CONSTRAINT","public","friendships","different_users","CHECK ((user_id <> friend_id))","CHECK"
"CONSTRAINT","public","friendships","friendships_friend_id_fkey","FOREIGN KEY (friend_id) REFERENCES users(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","public","friendships","friendships_pkey","PRIMARY KEY (id)","PRIMARY KEY"
"CONSTRAINT","public","friendships","friendships_user_id_fkey","FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","public","friendships","friendships_user_id_friend_id_key","UNIQUE (user_id, friend_id)","UNIQUE"
"CONSTRAINT","public","group_members","group_members_group_id_fkey","FOREIGN KEY (group_id) REFERENCES groups(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","public","group_members","group_members_group_id_user_id_key","UNIQUE (group_id, user_id)","UNIQUE"
"CONSTRAINT","public","group_members","group_members_pkey","PRIMARY KEY (id)","PRIMARY KEY"
"CONSTRAINT","public","group_members","group_members_user_id_fkey","FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","public","groups","groups_pkey","PRIMARY KEY (id)","PRIMARY KEY"
"CONSTRAINT","public","likes","like_belongs_to_one","CHECK ((((post_id IS NULL) AND (comment_id IS NOT NULL)) OR ((post_id IS NOT NULL) AND (comment_id IS NULL))))","CHECK"
"CONSTRAINT","public","likes","likes_comment_id_fkey","FOREIGN KEY (comment_id) REFERENCES comments(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","public","likes","likes_pkey","PRIMARY KEY (id)","PRIMARY KEY"
"CONSTRAINT","public","likes","likes_post_id_fkey","FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","public","likes","likes_user_id_fkey","FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","public","likes","likes_user_id_post_id_comment_id_key","UNIQUE (user_id, post_id, comment_id)","UNIQUE"
"CONSTRAINT","public","media","media_belongs_to_one","CHECK ((((post_id IS NULL) AND (message_id IS NOT NULL)) OR ((post_id IS NOT NULL) AND (message_id IS NULL))))","CHECK"
"CONSTRAINT","public","media","media_message_id_fkey","FOREIGN KEY (message_id) REFERENCES messages(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","public","media","media_pkey","PRIMARY KEY (id)","PRIMARY KEY"
"CONSTRAINT","public","media","media_post_id_fkey","FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","public","messages","messages_conversation_id_fkey","FOREIGN KEY (conversation_id) REFERENCES conversations(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","public","messages","messages_pkey","PRIMARY KEY (id)","PRIMARY KEY"
"CONSTRAINT","public","messages","messages_user_id_fkey","FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","public","notifications","notifications_actor_id_fkey","FOREIGN KEY (actor_id) REFERENCES users(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","public","notifications","notifications_pkey","PRIMARY KEY (id)","PRIMARY KEY"
"CONSTRAINT","public","notifications","notifications_user_id_fkey","FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","public","posts","posts_group_id_fkey","FOREIGN KEY (group_id) REFERENCES groups(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","public","posts","posts_pkey","PRIMARY KEY (id)","PRIMARY KEY"
"CONSTRAINT","public","posts","posts_user_id_fkey","FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","public","user_hidden_posts","user_hidden_posts_pkey","PRIMARY KEY (user_id, post_id)","PRIMARY KEY"
"CONSTRAINT","public","user_hidden_posts","user_hidden_posts_post_id_fkey","FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","public","user_hidden_posts","user_hidden_posts_user_id_fkey","FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","public","user_saved_posts","user_saved_posts_pkey","PRIMARY KEY (user_id, post_id)","PRIMARY KEY"
"CONSTRAINT","public","user_saved_posts","user_saved_posts_post_id_fkey","FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","public","user_saved_posts","user_saved_posts_user_id_fkey","FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","public","users","users_email_key","UNIQUE (email)","UNIQUE"
"CONSTRAINT","public","users","users_pkey","PRIMARY KEY (id)","PRIMARY KEY"
"CONSTRAINT","public","users","users_username_key","UNIQUE (username)","UNIQUE"
"CONSTRAINT","realtime","messages","messages_pkey","PRIMARY KEY (id, inserted_at)","PRIMARY KEY"
"CONSTRAINT","realtime","schema_migrations","schema_migrations_pkey","PRIMARY KEY (version)","PRIMARY KEY"
"CONSTRAINT","realtime","subscription","pk_subscription","PRIMARY KEY (id)","PRIMARY KEY"
"CONSTRAINT","storage","buckets","buckets_pkey","PRIMARY KEY (id)","PRIMARY KEY"
"CONSTRAINT","storage","migrations","migrations_name_key","UNIQUE (name)","UNIQUE"
"CONSTRAINT","storage","migrations","migrations_pkey","PRIMARY KEY (id)","PRIMARY KEY"
"CONSTRAINT","storage","objects","objects_bucketId_fkey","FOREIGN KEY (bucket_id) REFERENCES storage.buckets(id)","FOREIGN KEY"
"CONSTRAINT","storage","objects","objects_pkey","PRIMARY KEY (id)","PRIMARY KEY"
"CONSTRAINT","storage","s3_multipart_uploads","s3_multipart_uploads_bucket_id_fkey","FOREIGN KEY (bucket_id) REFERENCES storage.buckets(id)","FOREIGN KEY"
"CONSTRAINT","storage","s3_multipart_uploads","s3_multipart_uploads_pkey","PRIMARY KEY (id)","PRIMARY KEY"
"CONSTRAINT","storage","s3_multipart_uploads_parts","s3_multipart_uploads_parts_bucket_id_fkey","FOREIGN KEY (bucket_id) REFERENCES storage.buckets(id)","FOREIGN KEY"
"CONSTRAINT","storage","s3_multipart_uploads_parts","s3_multipart_uploads_parts_pkey","PRIMARY KEY (id)","PRIMARY KEY"
"CONSTRAINT","storage","s3_multipart_uploads_parts","s3_multipart_uploads_parts_upload_id_fkey","FOREIGN KEY (upload_id) REFERENCES storage.s3_multipart_uploads(id) ON DELETE CASCADE","FOREIGN KEY"
"CONSTRAINT","vault","secrets","secrets_key_id_fkey","FOREIGN KEY (key_id) REFERENCES pgsodium.key(id)","FOREIGN KEY"
"CONSTRAINT","vault","secrets","secrets_pkey","PRIMARY KEY (id)","PRIMARY KEY"
"EVENT TRIGGER","null","graphql_watch_ddl","ddl_command_end","graphql.increment_schema_version","O"
"EVENT TRIGGER","null","graphql_watch_drop","sql_drop","graphql.increment_schema_version","O"
"EVENT TRIGGER","null","issue_graphql_placeholder","sql_drop","set_graphql_placeholder","O"
"EVENT TRIGGER","null","issue_pg_cron_access","ddl_command_end","grant_pg_cron_access","O"
"EVENT TRIGGER","null","issue_pg_graphql_access","ddl_command_end","grant_pg_graphql_access","O"
"EVENT TRIGGER","null","issue_pg_net_access","ddl_command_end","grant_pg_net_access","O"
"EVENT TRIGGER","null","pgrst_ddl_watch","ddl_command_end","pgrst_ddl_watch","O"
"EVENT TRIGGER","null","pgrst_drop_watch","sql_drop","pgrst_drop_watch","O"
"EVENT TRIGGER","null","pgsodium_trg_mask_update","ddl_command_end","pgsodium.trg_mask_update","O"
"FUNCTION","auth","email","null","CREATE OR REPLACE FUNCTION auth.email()
 RETURNS text
 LANGUAGE sql
 STABLE
AS $function$
  select 
  coalesce(
    nullif(current_setting('request.jwt.claim.email', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'email')
  )::text
$function$
","Deprecated. Use auth.jwt() -> 'email' instead."
"FUNCTION","auth","jwt","null","CREATE OR REPLACE FUNCTION auth.jwt()
 RETURNS jsonb
 LANGUAGE sql
 STABLE
AS $function$
  select 
    coalesce(
        nullif(current_setting('request.jwt.claim', true), ''),
        nullif(current_setting('request.jwt.claims', true), '')
    )::jsonb
$function$
","null"
"FUNCTION","auth","role","null","CREATE OR REPLACE FUNCTION auth.role()
 RETURNS text
 LANGUAGE sql
 STABLE
AS $function$
  select 
  coalesce(
    nullif(current_setting('request.jwt.claim.role', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'role')
  )::text
$function$
","Deprecated. Use auth.jwt() -> 'role' instead."
"FUNCTION","auth","uid","null","CREATE OR REPLACE FUNCTION auth.uid()
 RETURNS uuid
 LANGUAGE sql
 STABLE
AS $function$
  select 
  coalesce(
    nullif(current_setting('request.jwt.claim.sub', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'sub')
  )::uuid
$function$
","Deprecated. Use auth.jwt() -> 'sub' instead."
"FUNCTION","extensions","algorithm_sign","null","CREATE OR REPLACE FUNCTION extensions.algorithm_sign(signables text, secret text, algorithm text)
 RETURNS text
 LANGUAGE sql
 IMMUTABLE
AS $function$
WITH
  alg AS (
    SELECT CASE
      WHEN algorithm = 'HS256' THEN 'sha256'
      WHEN algorithm = 'HS384' THEN 'sha384'
      WHEN algorithm = 'HS512' THEN 'sha512'
      ELSE '' END AS id)  -- hmac throws error
SELECT extensions.url_encode(extensions.hmac(signables, secret, alg.id)) FROM alg;
$function$
","null"
"FUNCTION","extensions","armor","null","CREATE OR REPLACE FUNCTION extensions.armor(bytea)
 RETURNS text
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_armor$function$
","null"
"FUNCTION","extensions","armor","null","CREATE OR REPLACE FUNCTION extensions.armor(bytea, text[], text[])
 RETURNS text
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_armor$function$
","null"
"FUNCTION","extensions","crypt","null","CREATE OR REPLACE FUNCTION extensions.crypt(text, text)
 RETURNS text
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_crypt$function$
","null"
"FUNCTION","extensions","dearmor","null","CREATE OR REPLACE FUNCTION extensions.dearmor(text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_dearmor$function$
","null"
"FUNCTION","extensions","decrypt","null","CREATE OR REPLACE FUNCTION extensions.decrypt(bytea, bytea, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_decrypt$function$
","null"
"FUNCTION","extensions","decrypt_iv","null","CREATE OR REPLACE FUNCTION extensions.decrypt_iv(bytea, bytea, bytea, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_decrypt_iv$function$
","null"
"FUNCTION","extensions","digest","null","CREATE OR REPLACE FUNCTION extensions.digest(text, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_digest$function$
","null"
"FUNCTION","extensions","digest","null","CREATE OR REPLACE FUNCTION extensions.digest(bytea, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_digest$function$
","null"
"FUNCTION","extensions","encrypt","null","CREATE OR REPLACE FUNCTION extensions.encrypt(bytea, bytea, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_encrypt$function$
","null"
"FUNCTION","extensions","encrypt_iv","null","CREATE OR REPLACE FUNCTION extensions.encrypt_iv(bytea, bytea, bytea, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_encrypt_iv$function$
","null"
"FUNCTION","extensions","gen_random_bytes","null","CREATE OR REPLACE FUNCTION extensions.gen_random_bytes(integer)
 RETURNS bytea
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_random_bytes$function$
","null"
"FUNCTION","extensions","gen_random_uuid","null","CREATE OR REPLACE FUNCTION extensions.gen_random_uuid()
 RETURNS uuid
 LANGUAGE c
 PARALLEL SAFE
AS '$libdir/pgcrypto', $function$pg_random_uuid$function$
","null"
"FUNCTION","extensions","gen_salt","null","CREATE OR REPLACE FUNCTION extensions.gen_salt(text, integer)
 RETURNS text
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_gen_salt_rounds$function$
","null"
"FUNCTION","extensions","gen_salt","null","CREATE OR REPLACE FUNCTION extensions.gen_salt(text)
 RETURNS text
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_gen_salt$function$
","null"
"FUNCTION","extensions","grant_pg_cron_access","null","CREATE OR REPLACE FUNCTION extensions.grant_pg_cron_access()
 RETURNS event_trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF EXISTS (
    SELECT
    FROM pg_event_trigger_ddl_commands() AS ev
    JOIN pg_extension AS ext
    ON ev.objid = ext.oid
    WHERE ext.extname = 'pg_cron'
  )
  THEN
    grant usage on schema cron to postgres with grant option;

    alter default privileges in schema cron grant all on tables to postgres with grant option;
    alter default privileges in schema cron grant all on functions to postgres with grant option;
    alter default privileges in schema cron grant all on sequences to postgres with grant option;

    alter default privileges for user supabase_admin in schema cron grant all
        on sequences to postgres with grant option;
    alter default privileges for user supabase_admin in schema cron grant all
        on tables to postgres with grant option;
    alter default privileges for user supabase_admin in schema cron grant all
        on functions to postgres with grant option;

    grant all privileges on all tables in schema cron to postgres with grant option;
    revoke all on table cron.job from postgres;
    grant select on table cron.job to postgres with grant option;
  END IF;
END;
$function$
","Grants access to pg_cron"
"FUNCTION","extensions","grant_pg_graphql_access","null","CREATE OR REPLACE FUNCTION extensions.grant_pg_graphql_access()
 RETURNS event_trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    func_is_graphql_resolve bool;
BEGIN
    func_is_graphql_resolve = (
        SELECT n.proname = 'resolve'
        FROM pg_event_trigger_ddl_commands() AS ev
        LEFT JOIN pg_catalog.pg_proc AS n
        ON ev.objid = n.oid
    );

    IF func_is_graphql_resolve
    THEN
        -- Update public wrapper to pass all arguments through to the pg_graphql resolve func
        DROP FUNCTION IF EXISTS graphql_public.graphql;
        create or replace function graphql_public.graphql(
            "operationName" text default null,
            query text default null,
            variables jsonb default null,
            extensions jsonb default null
        )
            returns jsonb
            language sql
        as $$
            select graphql.resolve(
                query := query,
                variables := coalesce(variables, '{}'),
                "operationName" := "operationName",
                extensions := extensions
            );
        $$;

        -- This hook executes when `graphql.resolve` is created. That is not necessarily the last
        -- function in the extension so we need to grant permissions on existing entities AND
        -- update default permissions to any others that are created after `graphql.resolve`
        grant usage on schema graphql to postgres, anon, authenticated, service_role;
        grant select on all tables in schema graphql to postgres, anon, authenticated, service_role;
        grant execute on all functions in schema graphql to postgres, anon, authenticated, service_role;
        grant all on all sequences in schema graphql to postgres, anon, authenticated, service_role;
        alter default privileges in schema graphql grant all on tables to postgres, anon, authenticated, service_role;
        alter default privileges in schema graphql grant all on functions to postgres, anon, authenticated, service_role;
        alter default privileges in schema graphql grant all on sequences to postgres, anon, authenticated, service_role;

        -- Allow postgres role to allow granting usage on graphql and graphql_public schemas to custom roles
        grant usage on schema graphql_public to postgres with grant option;
        grant usage on schema graphql to postgres with grant option;
    END IF;

END;
$function$
","Grants access to pg_graphql"
"FUNCTION","extensions","grant_pg_net_access","null","CREATE OR REPLACE FUNCTION extensions.grant_pg_net_access()
 RETURNS event_trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF EXISTS (
    SELECT 1
    FROM pg_event_trigger_ddl_commands() AS ev
    JOIN pg_extension AS ext
    ON ev.objid = ext.oid
    WHERE ext.extname = 'pg_net'
  )
  THEN
    IF NOT EXISTS (
      SELECT 1
      FROM pg_roles
      WHERE rolname = 'supabase_functions_admin'
    )
    THEN
      CREATE USER supabase_functions_admin NOINHERIT CREATEROLE LOGIN NOREPLICATION;
    END IF;

    GRANT USAGE ON SCHEMA net TO supabase_functions_admin, postgres, anon, authenticated, service_role;

    IF EXISTS (
      SELECT FROM pg_extension
      WHERE extname = 'pg_net'
      -- all versions in use on existing projects as of 2025-02-20
      -- version 0.12.0 onwards don't need these applied
      AND extversion IN ('0.2', '0.6', '0.7', '0.7.1', '0.8', '0.10.0', '0.11.0')
    ) THEN
      ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;
      ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;

      ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;
      ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;

      REVOKE ALL ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;
      REVOKE ALL ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;

      GRANT EXECUTE ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;
      GRANT EXECUTE ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;
    END IF;
  END IF;
END;
$function$
","Grants access to pg_net"
"FUNCTION","extensions","hmac","null","CREATE OR REPLACE FUNCTION extensions.hmac(bytea, bytea, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_hmac$function$
","null"
"FUNCTION","extensions","hmac","null","CREATE OR REPLACE FUNCTION extensions.hmac(text, text, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_hmac$function$
","null"
"FUNCTION","extensions","pg_stat_statements","null","CREATE OR REPLACE FUNCTION extensions.pg_stat_statements(showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT blk_read_time double precision, OUT blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision)
 RETURNS SETOF record
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pg_stat_statements', $function$pg_stat_statements_1_10$function$
","null"
"FUNCTION","extensions","pg_stat_statements_info","null","CREATE OR REPLACE FUNCTION extensions.pg_stat_statements_info(OUT dealloc bigint, OUT stats_reset timestamp with time zone)
 RETURNS record
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pg_stat_statements', $function$pg_stat_statements_info$function$
","null"
"FUNCTION","extensions","pg_stat_statements_reset","null","CREATE OR REPLACE FUNCTION extensions.pg_stat_statements_reset(userid oid DEFAULT 0, dbid oid DEFAULT 0, queryid bigint DEFAULT 0)
 RETURNS void
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pg_stat_statements', $function$pg_stat_statements_reset_1_7$function$
","null"
"FUNCTION","extensions","pgp_armor_headers","null","CREATE OR REPLACE FUNCTION extensions.pgp_armor_headers(text, OUT key text, OUT value text)
 RETURNS SETOF record
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_armor_headers$function$
","null"
"FUNCTION","extensions","pgp_key_id","null","CREATE OR REPLACE FUNCTION extensions.pgp_key_id(bytea)
 RETURNS text
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_key_id_w$function$
","null"
"FUNCTION","extensions","pgp_pub_decrypt","null","CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text, text)
 RETURNS text
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$
","null"
"FUNCTION","extensions","pgp_pub_decrypt","null","CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text)
 RETURNS text
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$
","null"
"FUNCTION","extensions","pgp_pub_decrypt","null","CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea)
 RETURNS text
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$
","null"
"FUNCTION","extensions","pgp_pub_decrypt_bytea","null","CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$
","null"
"FUNCTION","extensions","pgp_pub_decrypt_bytea","null","CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$
","null"
"FUNCTION","extensions","pgp_pub_decrypt_bytea","null","CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$
","null"
"FUNCTION","extensions","pgp_pub_encrypt","null","CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt(text, bytea)
 RETURNS bytea
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_encrypt_text$function$
","null"
"FUNCTION","extensions","pgp_pub_encrypt","null","CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt(text, bytea, text)
 RETURNS bytea
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_encrypt_text$function$
","null"
"FUNCTION","extensions","pgp_pub_encrypt_bytea","null","CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea)
 RETURNS bytea
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_encrypt_bytea$function$
","null"
"FUNCTION","extensions","pgp_pub_encrypt_bytea","null","CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea, text)
 RETURNS bytea
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_encrypt_bytea$function$
","null"
"FUNCTION","extensions","pgp_sym_decrypt","null","CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt(bytea, text, text)
 RETURNS text
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_sym_decrypt_text$function$
","null"
"FUNCTION","extensions","pgp_sym_decrypt","null","CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt(bytea, text)
 RETURNS text
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_sym_decrypt_text$function$
","null"
"FUNCTION","extensions","pgp_sym_decrypt_bytea","null","CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_sym_decrypt_bytea$function$
","null"
"FUNCTION","extensions","pgp_sym_decrypt_bytea","null","CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_sym_decrypt_bytea$function$
","null"
"FUNCTION","extensions","pgp_sym_encrypt","null","CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt(text, text, text)
 RETURNS bytea
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_sym_encrypt_text$function$
","null"
"FUNCTION","extensions","pgp_sym_encrypt","null","CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt(text, text)
 RETURNS bytea
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_sym_encrypt_text$function$
","null"
"FUNCTION","extensions","pgp_sym_encrypt_bytea","null","CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text, text)
 RETURNS bytea
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_sym_encrypt_bytea$function$
","null"
"FUNCTION","extensions","pgp_sym_encrypt_bytea","null","CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text)
 RETURNS bytea
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_sym_encrypt_bytea$function$
","null"
"FUNCTION","extensions","pgrst_ddl_watch","null","CREATE OR REPLACE FUNCTION extensions.pgrst_ddl_watch()
 RETURNS event_trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  cmd record;
BEGIN
  FOR cmd IN SELECT * FROM pg_event_trigger_ddl_commands()
  LOOP
    IF cmd.command_tag IN (
      'CREATE SCHEMA', 'ALTER SCHEMA'
    , 'CREATE TABLE', 'CREATE TABLE AS', 'SELECT INTO', 'ALTER TABLE'
    , 'CREATE FOREIGN TABLE', 'ALTER FOREIGN TABLE'
    , 'CREATE VIEW', 'ALTER VIEW'
    , 'CREATE MATERIALIZED VIEW', 'ALTER MATERIALIZED VIEW'
    , 'CREATE FUNCTION', 'ALTER FUNCTION'
    , 'CREATE TRIGGER'
    , 'CREATE TYPE', 'ALTER TYPE'
    , 'CREATE RULE'
    , 'COMMENT'
    )
    -- don't notify in case of CREATE TEMP table or other objects created on pg_temp
    AND cmd.schema_name is distinct from 'pg_temp'
    THEN
      NOTIFY pgrst, 'reload schema';
    END IF;
  END LOOP;
END; $function$
","null"
"FUNCTION","extensions","pgrst_drop_watch","null","CREATE OR REPLACE FUNCTION extensions.pgrst_drop_watch()
 RETURNS event_trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  obj record;
BEGIN
  FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()
  LOOP
    IF obj.object_type IN (
      'schema'
    , 'table'
    , 'foreign table'
    , 'view'
    , 'materialized view'
    , 'function'
    , 'trigger'
    , 'type'
    , 'rule'
    )
    AND obj.is_temporary IS false -- no pg_temp objects
    THEN
      NOTIFY pgrst, 'reload schema';
    END IF;
  END LOOP;
END; $function$
","null"
"FUNCTION","extensions","set_graphql_placeholder","null","CREATE OR REPLACE FUNCTION extensions.set_graphql_placeholder()
 RETURNS event_trigger
 LANGUAGE plpgsql
AS $function$
    DECLARE
    graphql_is_dropped bool;
    BEGIN
    graphql_is_dropped = (
        SELECT ev.schema_name = 'graphql_public'
        FROM pg_event_trigger_dropped_objects() AS ev
        WHERE ev.schema_name = 'graphql_public'
    );

    IF graphql_is_dropped
    THEN
        create or replace function graphql_public.graphql(
            "operationName" text default null,
            query text default null,
            variables jsonb default null,
            extensions jsonb default null
        )
            returns jsonb
            language plpgsql
        as $$
            DECLARE
                server_version float;
            BEGIN
                server_version = (SELECT (SPLIT_PART((select version()), ' ', 2))::float);

                IF server_version >= 14 THEN
                    RETURN jsonb_build_object(
                        'errors', jsonb_build_array(
                            jsonb_build_object(
                                'message', 'pg_graphql extension is not enabled.'
                            )
                        )
                    );
                ELSE
                    RETURN jsonb_build_object(
                        'errors', jsonb_build_array(
                            jsonb_build_object(
                                'message', 'pg_graphql is only available on projects running Postgres 14 onwards.'
                            )
                        )
                    );
                END IF;
            END;
        $$;
    END IF;

    END;
$function$
","Reintroduces placeholder function for graphql_public.graphql"
"FUNCTION","extensions","sign","null","CREATE OR REPLACE FUNCTION extensions.sign(payload json, secret text, algorithm text DEFAULT 'HS256'::text)
 RETURNS text
 LANGUAGE sql
 IMMUTABLE
AS $function$
WITH
  header AS (
    SELECT extensions.url_encode(convert_to('{"alg":"' || algorithm || '","typ":"JWT"}', 'utf8')) AS data
    ),
  payload AS (
    SELECT extensions.url_encode(convert_to(payload::text, 'utf8')) AS data
    ),
  signables AS (
    SELECT header.data || '.' || payload.data AS data FROM header, payload
    )
SELECT
    signables.data || '.' ||
    extensions.algorithm_sign(signables.data, secret, algorithm) FROM signables;
$function$
","null"
"FUNCTION","extensions","try_cast_double","null","CREATE OR REPLACE FUNCTION extensions.try_cast_double(inp text)
 RETURNS double precision
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
  BEGIN
    BEGIN
      RETURN inp::double precision;
    EXCEPTION
      WHEN OTHERS THEN RETURN NULL;
    END;
  END;
$function$
","null"
"FUNCTION","extensions","url_decode","null","CREATE OR REPLACE FUNCTION extensions.url_decode(data text)
 RETURNS bytea
 LANGUAGE sql
 IMMUTABLE
AS $function$
WITH t AS (SELECT translate(data, '-_', '+/') AS trans),
     rem AS (SELECT length(t.trans) % 4 AS remainder FROM t) -- compute padding size
    SELECT decode(
        t.trans ||
        CASE WHEN rem.remainder > 0
           THEN repeat('=', (4 - rem.remainder))
           ELSE '' END,
    'base64') FROM t, rem;
$function$
","null"
"FUNCTION","extensions","url_encode","null","CREATE OR REPLACE FUNCTION extensions.url_encode(data bytea)
 RETURNS text
 LANGUAGE sql
 IMMUTABLE
AS $function$
    SELECT translate(encode(data, 'base64'), E'+/=\n', '-_');
$function$
","null"
"FUNCTION","extensions","uuid_generate_v1","null","CREATE OR REPLACE FUNCTION extensions.uuid_generate_v1()
 RETURNS uuid
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_generate_v1$function$
","null"
"FUNCTION","extensions","uuid_generate_v1mc","null","CREATE OR REPLACE FUNCTION extensions.uuid_generate_v1mc()
 RETURNS uuid
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_generate_v1mc$function$
","null"
"FUNCTION","extensions","uuid_generate_v3","null","CREATE OR REPLACE FUNCTION extensions.uuid_generate_v3(namespace uuid, name text)
 RETURNS uuid
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_generate_v3$function$
","null"
"FUNCTION","extensions","uuid_generate_v4","null","CREATE OR REPLACE FUNCTION extensions.uuid_generate_v4()
 RETURNS uuid
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_generate_v4$function$
","null"
"FUNCTION","extensions","uuid_generate_v5","null","CREATE OR REPLACE FUNCTION extensions.uuid_generate_v5(namespace uuid, name text)
 RETURNS uuid
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_generate_v5$function$
","null"
"FUNCTION","extensions","uuid_nil","null","CREATE OR REPLACE FUNCTION extensions.uuid_nil()
 RETURNS uuid
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_nil$function$
","null"
"FUNCTION","extensions","uuid_ns_dns","null","CREATE OR REPLACE FUNCTION extensions.uuid_ns_dns()
 RETURNS uuid
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_ns_dns$function$
","null"
"FUNCTION","extensions","uuid_ns_oid","null","CREATE OR REPLACE FUNCTION extensions.uuid_ns_oid()
 RETURNS uuid
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_ns_oid$function$
","null"
"FUNCTION","extensions","uuid_ns_url","null","CREATE OR REPLACE FUNCTION extensions.uuid_ns_url()
 RETURNS uuid
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_ns_url$function$
","null"
"FUNCTION","extensions","uuid_ns_x500","null","CREATE OR REPLACE FUNCTION extensions.uuid_ns_x500()
 RETURNS uuid
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_ns_x500$function$
","null"
"FUNCTION","extensions","verify","null","CREATE OR REPLACE FUNCTION extensions.verify(token text, secret text, algorithm text DEFAULT 'HS256'::text)
 RETURNS TABLE(header json, payload json, valid boolean)
 LANGUAGE sql
 IMMUTABLE
AS $function$
  SELECT
    jwt.header AS header,
    jwt.payload AS payload,
    jwt.signature_ok AND tstzrange(
      to_timestamp(extensions.try_cast_double(jwt.payload->>'nbf')),
      to_timestamp(extensions.try_cast_double(jwt.payload->>'exp'))
    ) @> CURRENT_TIMESTAMP AS valid
  FROM (
    SELECT
      convert_from(extensions.url_decode(r[1]), 'utf8')::json AS header,
      convert_from(extensions.url_decode(r[2]), 'utf8')::json AS payload,
      r[3] = extensions.algorithm_sign(r[1] || '.' || r[2], secret, algorithm) AS signature_ok
    FROM regexp_split_to_array(token, '\.') r
  ) jwt
$function$
","null"
"FUNCTION","graphql","_internal_resolve","null","CREATE OR REPLACE FUNCTION graphql._internal_resolve(query text, variables jsonb DEFAULT '{}'::jsonb, "operationName" text DEFAULT NULL::text, extensions jsonb DEFAULT NULL::jsonb)
 RETURNS jsonb
 LANGUAGE c
AS '$libdir/pg_graphql', $function$resolve_wrapper$function$
","null"
"FUNCTION","graphql","comment_directive","null","CREATE OR REPLACE FUNCTION graphql.comment_directive(comment_ text)
 RETURNS jsonb
 LANGUAGE sql
 IMMUTABLE
AS $function$
    /*
    comment on column public.account.name is '@graphql.name: myField'
    */
    select
        coalesce(
            (
                regexp_match(
                    comment_,
                    '@graphql\((.+)\)'
                )
            )[1]::jsonb,
            jsonb_build_object()
        )
$function$
","null"
"FUNCTION","graphql","exception","null","CREATE OR REPLACE FUNCTION graphql.exception(message text)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
begin
    raise exception using errcode='22000', message=message;
end;
$function$
","null"
"FUNCTION","graphql","get_schema_version","null","CREATE OR REPLACE FUNCTION graphql.get_schema_version()
 RETURNS integer
 LANGUAGE sql
 SECURITY DEFINER
AS $function$
    select last_value from graphql.seq_schema_version;
$function$
","null"
"FUNCTION","graphql","increment_schema_version","null","CREATE OR REPLACE FUNCTION graphql.increment_schema_version()
 RETURNS event_trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
    perform pg_catalog.nextval('graphql.seq_schema_version');
end;
$function$
","null"
"FUNCTION","graphql","resolve","null","CREATE OR REPLACE FUNCTION graphql.resolve(query text, variables jsonb DEFAULT '{}'::jsonb, "operationName" text DEFAULT NULL::text, extensions jsonb DEFAULT NULL::jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
declare
    res jsonb;
    message_text text;
begin
  begin
    select graphql._internal_resolve("query" := "query",
                                     "variables" := "variables",
                                     "operationName" := "operationName",
                                     "extensions" := "extensions") into res;
    return res;
  exception
    when others then
    get stacked diagnostics message_text = message_text;
    return
    jsonb_build_object('data', null,
                       'errors', jsonb_build_array(jsonb_build_object('message', message_text)));
  end;
end;
$function$
","null"
"FUNCTION","graphql_public","graphql","null","CREATE OR REPLACE FUNCTION graphql_public.graphql("operationName" text DEFAULT NULL::text, query text DEFAULT NULL::text, variables jsonb DEFAULT NULL::jsonb, extensions jsonb DEFAULT NULL::jsonb)
 RETURNS jsonb
 LANGUAGE sql
AS $function$
            select graphql.resolve(
                query := query,
                variables := coalesce(variables, '{}'),
                "operationName" := "operationName",
                extensions := extensions
            );
        $function$
","null"
"FUNCTION","pgbouncer","get_auth","null","CREATE OR REPLACE FUNCTION pgbouncer.get_auth(p_usename text)
 RETURNS TABLE(username text, password text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RAISE WARNING 'PgBouncer auth request: %', p_usename;

    RETURN QUERY
    SELECT usename::TEXT, passwd::TEXT FROM pg_catalog.pg_shadow
    WHERE usename = p_usename;
END;
$function$
","null"
"FUNCTION","pgsodium","create_key","null","CREATE OR REPLACE FUNCTION pgsodium.create_key(key_type pgsodium.key_type DEFAULT 'aead-det'::pgsodium.key_type, name text DEFAULT NULL::text, raw_key bytea DEFAULT NULL::bytea, raw_key_nonce bytea DEFAULT NULL::bytea, parent_key uuid DEFAULT NULL::uuid, key_context bytea DEFAULT '\x7067736f6469756d'::bytea, expires timestamp with time zone DEFAULT NULL::timestamp with time zone, associated_data text DEFAULT ''::text)
 RETURNS pgsodium.valid_key
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  new_key pgsodium.key;
  valid_key pgsodium.valid_key;
BEGIN
  INSERT INTO pgsodium.key (key_id, key_context, key_type, raw_key,
  raw_key_nonce, parent_key, expires, name, associated_data)
      VALUES (
        CASE WHEN raw_key IS NULL THEN
            NEXTVAL('pgsodium.key_key_id_seq'::REGCLASS)
        ELSE NULL END,
        CASE WHEN raw_key IS NULL THEN
            key_context
        ELSE NULL END,
        key_type,
        raw_key,
        CASE WHEN raw_key IS NOT NULL THEN
            COALESCE(raw_key_nonce, pgsodium.crypto_aead_det_noncegen())
        ELSE NULL END,
        CASE WHEN parent_key IS NULL and raw_key IS NOT NULL THEN
            (pgsodium.create_key('aead-det')).id
        ELSE parent_key END,
        expires,
        name,
        associated_data)
    RETURNING * INTO new_key;
  SELECT * INTO valid_key FROM pgsodium.valid_key WHERE id = new_key.id;
  RETURN valid_key;
END;
$function$
","null"
"FUNCTION","pgsodium","create_mask_view","null","CREATE OR REPLACE FUNCTION pgsodium.create_mask_view(relid oid, subid integer, debug boolean DEFAULT false)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'pg_catalog'
AS $function$
DECLARE
  m record;
  body text;
  source_name text;
  view_owner regrole = session_user;
  rule pgsodium.masking_rule;
  privs aclitem[];
  priv record;
BEGIN
  SELECT DISTINCT * INTO STRICT rule FROM pgsodium.masking_rule WHERE attrelid = relid AND attnum = subid;

  source_name := relid::regclass::text;

  BEGIN
    SELECT relacl INTO STRICT privs FROM pg_catalog.pg_class WHERE oid = rule.view_name::regclass::oid;
  EXCEPTION
	WHEN undefined_table THEN
      SELECT relacl INTO STRICT privs FROM pg_catalog.pg_class WHERE oid = relid;
  END;

  body = format(
    $c$
    DROP VIEW IF EXISTS %1$s;
    CREATE VIEW %1$s %5$s AS SELECT %2$s
    FROM %3$s;
    ALTER VIEW %1$s OWNER TO %4$s;
    $c$,
    rule.view_name,
    pgsodium.decrypted_columns(relid),
    source_name,
    view_owner,
    CASE WHEN rule.security_invoker THEN 'WITH (security_invoker=true)' ELSE '' END
  );
  IF debug THEN
    RAISE NOTICE '%', body;
  END IF;
  EXECUTE body;

  FOR priv IN SELECT * FROM pg_catalog.aclexplode(privs) LOOP
	body = format(
	  $c$
	  GRANT %s ON %s TO %s;
	  $c$,
	  priv.privilege_type,
	  rule.view_name,
	  priv.grantee::regrole::text
	);
	IF debug THEN
	  RAISE NOTICE '%', body;
	END IF;
	EXECUTE body;
  END LOOP;

  FOR m IN SELECT * FROM pgsodium.mask_columns where attrelid = relid LOOP
	IF m.key_id IS NULL AND m.key_id_column is NULL THEN
	  CONTINUE;
	ELSE
	  body = format(
		$c$
		DROP FUNCTION IF EXISTS %1$s."%2$s_encrypt_secret_%3$s"() CASCADE;

		CREATE OR REPLACE FUNCTION %1$s."%2$s_encrypt_secret_%3$s"()
		  RETURNS TRIGGER
		  LANGUAGE plpgsql
		  AS $t$
		BEGIN
		%4$s;
		RETURN new;
		END;
		$t$;

		ALTER FUNCTION  %1$s."%2$s_encrypt_secret_%3$s"() OWNER TO %5$s;

		DROP TRIGGER IF EXISTS "%2$s_encrypt_secret_trigger_%3$s" ON %6$s;

		CREATE TRIGGER "%2$s_encrypt_secret_trigger_%3$s"
		  BEFORE INSERT OR UPDATE OF "%3$s" ON %6$s
		  FOR EACH ROW
		  EXECUTE FUNCTION %1$s."%2$s_encrypt_secret_%3$s" ();
		  $c$,
		rule.relnamespace,
		rule.relname,
		m.attname,
		pgsodium.encrypted_column(relid, m),
		view_owner,
		source_name
	  );
	  if debug THEN
		RAISE NOTICE '%', body;
	  END IF;
	  EXECUTE body;
	END IF;
  END LOOP;

  raise notice 'about to masking role % %', source_name, rule.view_name;
  PERFORM pgsodium.mask_role(oid::regrole, source_name, rule.view_name)
  FROM pg_roles WHERE pgsodium.has_mask(oid::regrole, source_name);

  RETURN;
END
  $function$
","null"
"FUNCTION","pgsodium","create_mask_view","null","CREATE OR REPLACE FUNCTION pgsodium.create_mask_view(relid oid, debug boolean DEFAULT false)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'pg_catalog'
AS $function$
DECLARE
  body text;
  source_name text;
  view_name text;
  rule pgsodium.masking_rule;
BEGIN
  SELECT DISTINCT(quote_ident(relname)) INTO STRICT view_name
    FROM pg_class c, pg_seclabel sl
   WHERE relid = c.oid
     AND sl.classoid = c.tableoid
     AND sl.objoid = c.oid;

  source_name := relid::regclass;

  body = format(
    $c$
    DROP VIEW IF EXISTS pgsodium_masks.%s;
    CREATE VIEW pgsodium_masks.%s AS SELECT %s
    FROM %s;
    $c$,
    view_name,
    view_name,
    pgsodium.decrypted_columns(relid),
    source_name
  );
  IF debug THEN
    RAISE NOTICE '%', body;
  END IF;
  EXECUTE body;

  body = format(
    $c$
    CREATE OR REPLACE FUNCTION pgsodium_masks.%s_encrypt_secret()
      RETURNS TRIGGER
      LANGUAGE plpgsql
      AS $t$
    BEGIN
    %s;
    RETURN new;
    END;
    $t$;

    DROP TRIGGER IF EXISTS %s_encrypt_secret_trigger ON %s;

    CREATE TRIGGER %s_encrypt_secret_trigger
      BEFORE INSERT ON %s
      FOR EACH ROW
      EXECUTE FUNCTION pgsodium_masks.%s_encrypt_secret ();
    $c$,
    view_name,
    pgsodium.encrypted_columns(relid),
    view_name,
    source_name,
    view_name,
    source_name,
    view_name
  );
  if debug THEN
    RAISE NOTICE '%', body;
  END IF;
  EXECUTE body;

  PERFORM pgsodium.mask_role(oid::regrole, source_name, view_name)
  FROM pg_roles WHERE pgsodium.has_mask(oid::regrole, source_name);

  RETURN;
END
  $function$
","null"
"FUNCTION","pgsodium","crypto_aead_det_decrypt","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_aead_det_decrypt(message bytea, additional bytea, key_uuid uuid)
 RETURNS bytea
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  key pgsodium.decrypted_key;
BEGIN
  SELECT * INTO STRICT key
    FROM pgsodium.decrypted_key v
  WHERE id = key_uuid AND key_type = 'aead-det';

  IF key.decrypted_raw_key IS NOT NULL THEN
    RETURN pgsodium.crypto_aead_det_decrypt(message, additional, key.decrypted_raw_key);
  END IF;
  RETURN pgsodium.crypto_aead_det_decrypt(message, additional, key.key_id, key.key_context);
END;
  $function$
","null"
"FUNCTION","pgsodium","crypto_aead_det_decrypt","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_aead_det_decrypt(message bytea, additional bytea, key_uuid uuid, nonce bytea)
 RETURNS bytea
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  key pgsodium.decrypted_key;
BEGIN
  SELECT * INTO STRICT key
    FROM pgsodium.decrypted_key v
  WHERE id = key_uuid AND key_type = 'aead-det';

  IF key.decrypted_raw_key IS NOT NULL THEN
    RETURN pgsodium.crypto_aead_det_decrypt(message, additional, key.decrypted_raw_key, nonce);
  END IF;
  RETURN pgsodium.crypto_aead_det_decrypt(message, additional, key.key_id, key.key_context, nonce);
END;
  $function$
","null"
"FUNCTION","pgsodium","crypto_aead_det_decrypt","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_aead_det_decrypt(ciphertext bytea, additional bytea, key bytea, nonce bytea DEFAULT NULL::bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_aead_det_decrypt$function$
","null"
"FUNCTION","pgsodium","crypto_aead_det_decrypt","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_aead_det_decrypt(message bytea, additional bytea, key_id bigint, context bytea DEFAULT '\x7067736f6469756d'::bytea, nonce bytea DEFAULT NULL::bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_aead_det_decrypt_by_id$function$
","null"
"FUNCTION","pgsodium","crypto_aead_det_encrypt","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_aead_det_encrypt(message bytea, additional bytea, key_id bigint, context bytea DEFAULT '\x7067736f6469756d'::bytea, nonce bytea DEFAULT NULL::bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_aead_det_encrypt_by_id$function$
","null"
"FUNCTION","pgsodium","crypto_aead_det_encrypt","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_aead_det_encrypt(message bytea, additional bytea, key_uuid uuid, nonce bytea)
 RETURNS bytea
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  key pgsodium.decrypted_key;
BEGIN
  SELECT * INTO STRICT key
    FROM pgsodium.decrypted_key v
  WHERE id = key_uuid AND key_type = 'aead-det';

  IF key.decrypted_raw_key IS NOT NULL THEN
    RETURN pgsodium.crypto_aead_det_encrypt(message, additional, key.decrypted_raw_key, nonce);
  END IF;
  RETURN pgsodium.crypto_aead_det_encrypt(message, additional, key.key_id, key.key_context, nonce);
END;
  $function$
","null"
"FUNCTION","pgsodium","crypto_aead_det_encrypt","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_aead_det_encrypt(message bytea, additional bytea, key bytea, nonce bytea DEFAULT NULL::bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_aead_det_encrypt$function$
","null"
"FUNCTION","pgsodium","crypto_aead_det_encrypt","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_aead_det_encrypt(message bytea, additional bytea, key_uuid uuid)
 RETURNS bytea
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  key pgsodium.decrypted_key;
BEGIN
  SELECT * INTO STRICT key
    FROM pgsodium.decrypted_key v
  WHERE id = key_uuid AND key_type = 'aead-det';

  IF key.decrypted_raw_key IS NOT NULL THEN
    RETURN pgsodium.crypto_aead_det_encrypt(message, additional, key.decrypted_raw_key);
  END IF;
  RETURN pgsodium.crypto_aead_det_encrypt(message, additional, key.key_id, key.key_context);
END;
  $function$
","null"
"FUNCTION","pgsodium","crypto_aead_det_keygen","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_aead_det_keygen()
 RETURNS bytea
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_crypto_aead_det_keygen$function$
","null"
"FUNCTION","pgsodium","crypto_aead_det_noncegen","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_aead_det_noncegen()
 RETURNS bytea
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_crypto_aead_det_noncegen$function$
","null"
"FUNCTION","pgsodium","crypto_aead_ietf_decrypt","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_aead_ietf_decrypt(message bytea, additional bytea, nonce bytea, key_uuid uuid)
 RETURNS bytea
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  key pgsodium.decrypted_key;
BEGIN
  SELECT * INTO STRICT key
    FROM pgsodium.decrypted_key v
  WHERE id = key_uuid AND key_type = 'aead-ietf';

  IF key.decrypted_raw_key IS NOT NULL THEN
    RETURN pgsodium.crypto_aead_ietf_decrypt(message, additional, nonce, key.decrypted_raw_key);
  END IF;
  RETURN pgsodium.crypto_aead_ietf_decrypt(message, additional, nonce, key.key_id, key.key_context);
END;
  $function$
","null"
"FUNCTION","pgsodium","crypto_aead_ietf_decrypt","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_aead_ietf_decrypt(message bytea, additional bytea, nonce bytea, key_id bigint, context bytea DEFAULT '\x7067736f6469756d'::bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_aead_ietf_decrypt_by_id$function$
","null"
"FUNCTION","pgsodium","crypto_aead_ietf_decrypt","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_aead_ietf_decrypt(message bytea, additional bytea, nonce bytea, key bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_aead_ietf_decrypt$function$
","null"
"FUNCTION","pgsodium","crypto_aead_ietf_encrypt","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_aead_ietf_encrypt(message bytea, additional bytea, nonce bytea, key bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_aead_ietf_encrypt$function$
","null"
"FUNCTION","pgsodium","crypto_aead_ietf_encrypt","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_aead_ietf_encrypt(message bytea, additional bytea, nonce bytea, key_id bigint, context bytea DEFAULT '\x7067736f6469756d'::bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_aead_ietf_encrypt_by_id$function$
","null"
"FUNCTION","pgsodium","crypto_aead_ietf_encrypt","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_aead_ietf_encrypt(message bytea, additional bytea, nonce bytea, key_uuid uuid)
 RETURNS bytea
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  key pgsodium.decrypted_key;
BEGIN
  SELECT * INTO STRICT key
    FROM pgsodium.decrypted_key v
  WHERE id = key_uuid AND key_type = 'aead-ietf';

  IF key.decrypted_raw_key IS NOT NULL THEN
    RETURN pgsodium.crypto_aead_ietf_encrypt(message, additional, nonce, key.decrypted_raw_key);
  END IF;
  RETURN pgsodium.crypto_aead_ietf_encrypt(message, additional, nonce, key.key_id, key.key_context);
END;
  $function$
","null"
"FUNCTION","pgsodium","crypto_aead_ietf_keygen","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_aead_ietf_keygen()
 RETURNS bytea
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_crypto_aead_ietf_keygen$function$
","null"
"FUNCTION","pgsodium","crypto_aead_ietf_noncegen","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_aead_ietf_noncegen()
 RETURNS bytea
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_crypto_aead_ietf_noncegen$function$
","null"
"FUNCTION","pgsodium","crypto_auth","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_auth(message bytea, key_uuid uuid)
 RETURNS bytea
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  key pgsodium.decrypted_key;
BEGIN
  SELECT * INTO STRICT key
    FROM pgsodium.decrypted_key v
  WHERE id = key_uuid AND key_type = 'auth';

  IF key.decrypted_raw_key IS NOT NULL THEN
    RETURN pgsodium.crypto_auth(message, key.decrypted_raw_key);
  END IF;
  RETURN pgsodium.crypto_auth(message, key.key_id, key.key_context);
END;

$function$
","null"
"FUNCTION","pgsodium","crypto_auth","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_auth(message bytea, key bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_auth$function$
","null"
"FUNCTION","pgsodium","crypto_auth","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_auth(message bytea, key_id bigint, context bytea DEFAULT '\x7067736f6469756d'::bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_auth_by_id$function$
","null"
"FUNCTION","pgsodium","crypto_auth_hmacsha256","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha256(message bytea, key_id bigint, context bytea DEFAULT '\x7067736f6469756d'::bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_auth_hmacsha256_by_id$function$
","null"
"FUNCTION","pgsodium","crypto_auth_hmacsha256","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha256(message bytea, secret bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_auth_hmacsha256$function$
","null"
"FUNCTION","pgsodium","crypto_auth_hmacsha256","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha256(message bytea, key_uuid uuid)
 RETURNS bytea
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  key pgsodium.decrypted_key;
BEGIN
  SELECT * INTO STRICT key
    FROM pgsodium.decrypted_key v
  WHERE id = key_uuid AND key_type = 'hmacsha256';

  IF key.decrypted_raw_key IS NOT NULL THEN
    RETURN pgsodium.crypto_auth_hmacsha256(message, key.decrypted_raw_key);
  END IF;
  RETURN pgsodium.crypto_auth_hmacsha256(message, key.key_id, key.key_context);
END;

$function$
","null"
"FUNCTION","pgsodium","crypto_auth_hmacsha256_keygen","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha256_keygen()
 RETURNS bytea
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_crypto_auth_hmacsha256_keygen$function$
","null"
"FUNCTION","pgsodium","crypto_auth_hmacsha256_verify","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha256_verify(signature bytea, message bytea, key_uuid uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  key pgsodium.decrypted_key;
BEGIN
  SELECT * INTO STRICT key
    FROM pgsodium.decrypted_key v
  WHERE id = key_uuid AND key_type = 'hmacsha256';

  IF key.decrypted_raw_key IS NOT NULL THEN
    RETURN pgsodium.crypto_auth_hmacsha256_verify(signature, message, key.decrypted_raw_key);
  END IF;
  RETURN pgsodium.crypto_auth_hmacsha256_verify(signature, message, key.key_id, key.key_context);
END;

$function$
","null"
"FUNCTION","pgsodium","crypto_auth_hmacsha256_verify","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha256_verify(hash bytea, message bytea, secret bytea)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_auth_hmacsha256_verify$function$
","null"
"FUNCTION","pgsodium","crypto_auth_hmacsha256_verify","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha256_verify(hash bytea, message bytea, key_id bigint, context bytea DEFAULT '\x7067736f6469756d'::bytea)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_auth_hmacsha256_verify_by_id$function$
","null"
"FUNCTION","pgsodium","crypto_auth_hmacsha512","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha512(message bytea, key_id bigint, context bytea DEFAULT '\x7067736f6469756d'::bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_auth_hmacsha512_by_id$function$
","null"
"FUNCTION","pgsodium","crypto_auth_hmacsha512","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha512(message bytea, secret bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_auth_hmacsha512$function$
","null"
"FUNCTION","pgsodium","crypto_auth_hmacsha512","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha512(message bytea, key_uuid uuid)
 RETURNS bytea
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  key pgsodium.decrypted_key;
BEGIN
  SELECT * INTO STRICT key
    FROM pgsodium.decrypted_key v
  WHERE id = key_uuid AND key_type = 'hmacsha512';

  IF key.decrypted_raw_key IS NOT NULL THEN
    RETURN pgsodium.crypto_auth_hmacsha512(message, key.decrypted_raw_key);
  END IF;
  RETURN pgsodium.crypto_auth_hmacsha512(message, key.key_id, key.key_context);
END;

$function$
","null"
"FUNCTION","pgsodium","crypto_auth_hmacsha512_keygen","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha512_keygen()
 RETURNS bytea
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_crypto_auth_hmacsha512_keygen$function$
","null"
"FUNCTION","pgsodium","crypto_auth_hmacsha512_verify","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha512_verify(signature bytea, message bytea, key_uuid uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  key pgsodium.decrypted_key;
BEGIN
  SELECT * INTO STRICT key
    FROM pgsodium.decrypted_key v
  WHERE id = key_uuid AND key_type = 'hmacsha512';

  IF key.decrypted_raw_key IS NOT NULL THEN
    RETURN pgsodium.crypto_auth_hmacsha512_verify(signature, message, key.decrypted_raw_key);
  END IF;
  RETURN pgsodium.crypto_auth_hmacsha512_verify(signature, message, key.key_id, key.key_context);
END;

$function$
","null"
"FUNCTION","pgsodium","crypto_auth_hmacsha512_verify","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha512_verify(hash bytea, message bytea, secret bytea)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_auth_hmacsha512_verify$function$
","null"
"FUNCTION","pgsodium","crypto_auth_hmacsha512_verify","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha512_verify(hash bytea, message bytea, key_id bigint, context bytea DEFAULT '\x7067736f6469756d'::bytea)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_auth_hmacsha512_verify_by_id$function$
","null"
"FUNCTION","pgsodium","crypto_auth_keygen","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_auth_keygen()
 RETURNS bytea
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_crypto_auth_keygen$function$
","null"
"FUNCTION","pgsodium","crypto_auth_verify","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_auth_verify(mac bytea, message bytea, key_uuid uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  key pgsodium.decrypted_key;
BEGIN
  SELECT * INTO STRICT key
    FROM pgsodium.decrypted_key v
  WHERE id = key_uuid AND key_type = 'auth';

  IF key.decrypted_raw_key IS NOT NULL THEN
    RETURN pgsodium.crypto_auth_verify(mac, message, key.decrypted_raw_key);
  END IF;
  RETURN pgsodium.crypto_auth_verify(mac, message, key.key_id, key.key_context);
END;

$function$
","null"
"FUNCTION","pgsodium","crypto_auth_verify","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_auth_verify(mac bytea, message bytea, key bytea)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_auth_verify$function$
","null"
"FUNCTION","pgsodium","crypto_auth_verify","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_auth_verify(mac bytea, message bytea, key_id bigint, context bytea DEFAULT '\x7067736f6469756d'::bytea)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_auth_verify_by_id$function$
","null"
"FUNCTION","pgsodium","crypto_box","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_box(message bytea, nonce bytea, public bytea, secret bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_box$function$
","null"
"FUNCTION","pgsodium","crypto_box_new_keypair","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_box_new_keypair()
 RETURNS pgsodium.crypto_box_keypair
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_crypto_box_keypair$function$
","null"
"FUNCTION","pgsodium","crypto_box_new_seed","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_box_new_seed()
 RETURNS bytea
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_crypto_box_new_seed$function$
","null"
"FUNCTION","pgsodium","crypto_box_noncegen","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_box_noncegen()
 RETURNS bytea
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_crypto_box_noncegen$function$
","null"
"FUNCTION","pgsodium","crypto_box_open","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_box_open(ciphertext bytea, nonce bytea, public bytea, secret bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_box_open$function$
","null"
"FUNCTION","pgsodium","crypto_box_seal","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_box_seal(message bytea, public_key bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_box_seal$function$
","null"
"FUNCTION","pgsodium","crypto_box_seal_open","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_box_seal_open(ciphertext bytea, public_key bytea, secret_key bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_box_seal_open$function$
","null"
"FUNCTION","pgsodium","crypto_box_seed_new_keypair","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_box_seed_new_keypair(seed bytea)
 RETURNS pgsodium.crypto_box_keypair
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_box_seed_keypair$function$
","null"
"FUNCTION","pgsodium","crypto_cmp","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_cmp(text, text)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE STRICT
AS '$libdir/pgsodium', $function$pgsodium_cmp$function$
","null"
"FUNCTION","pgsodium","crypto_generichash","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_generichash(message bytea, key_uuid uuid)
 RETURNS bytea
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  key pgsodium.decrypted_key;
BEGIN
  SELECT * INTO STRICT key
    FROM pgsodium.decrypted_key v
  WHERE id = key_uuid AND key_type = 'generichash';

  IF key.decrypted_raw_key IS NOT NULL THEN
    RETURN pgsodium.crypto_generichash(message, key.decrypted_raw_key);
  END IF;
  RETURN pgsodium.crypto_generichash(message, key.key_id, key.key_context);
END;

$function$
","null"
"FUNCTION","pgsodium","crypto_generichash","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_generichash(message bytea, key bytea DEFAULT NULL::bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_generichash$function$
","null"
"FUNCTION","pgsodium","crypto_generichash","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_generichash(message bytea, key bigint, context bytea DEFAULT '\x7067736f6469756d'::bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_generichash_by_id$function$
","null"
"FUNCTION","pgsodium","crypto_generichash_keygen","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_generichash_keygen()
 RETURNS bytea
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_crypto_generichash_keygen$function$
","null"
"FUNCTION","pgsodium","crypto_hash_sha256","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_hash_sha256(message bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_hash_sha256$function$
","null"
"FUNCTION","pgsodium","crypto_hash_sha512","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_hash_sha512(message bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_hash_sha512$function$
","null"
"FUNCTION","pgsodium","crypto_kdf_derive_from_key","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_kdf_derive_from_key(subkey_size bigint, subkey_id bigint, context bytea, primary_key bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_kdf_derive_from_key$function$
","null"
"FUNCTION","pgsodium","crypto_kdf_derive_from_key","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_kdf_derive_from_key(subkey_size integer, subkey_id bigint, context bytea, primary_key uuid)
 RETURNS bytea
 LANGUAGE plpgsql
 STABLE STRICT SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  key pgsodium.decrypted_key;
BEGIN
  SELECT * INTO STRICT key
    FROM pgsodium.decrypted_key v
  WHERE id = primary_key AND key_type = 'kdf';

  IF key.decrypted_raw_key IS NOT NULL THEN
    RETURN pgsodium.crypto_kdf_derive_from_key(subkey_size, subkey_id, context, key.decrypted_raw_key);
  END IF;
  RETURN pgsodium.derive_key(key.key_id, subkey_size, key.key_context);
END;

$function$
","null"
"FUNCTION","pgsodium","crypto_kdf_keygen","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_kdf_keygen()
 RETURNS bytea
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_crypto_kdf_keygen$function$
","null"
"FUNCTION","pgsodium","crypto_kx_client_session_keys","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_kx_client_session_keys(client_pk bytea, client_sk bytea, server_pk bytea)
 RETURNS pgsodium.crypto_kx_session
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_crypto_kx_client_session_keys$function$
","null"
"FUNCTION","pgsodium","crypto_kx_new_keypair","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_kx_new_keypair()
 RETURNS pgsodium.crypto_kx_keypair
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_crypto_kx_keypair$function$
","null"
"FUNCTION","pgsodium","crypto_kx_new_seed","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_kx_new_seed()
 RETURNS bytea
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_crypto_kx_new_seed$function$
","null"
"FUNCTION","pgsodium","crypto_kx_seed_new_keypair","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_kx_seed_new_keypair(seed bytea)
 RETURNS pgsodium.crypto_kx_keypair
 LANGUAGE c
 IMMUTABLE STRICT
AS '$libdir/pgsodium', $function$pgsodium_crypto_kx_seed_keypair$function$
","null"
"FUNCTION","pgsodium","crypto_kx_server_session_keys","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_kx_server_session_keys(server_pk bytea, server_sk bytea, client_pk bytea)
 RETURNS pgsodium.crypto_kx_session
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_crypto_kx_server_session_keys$function$
","null"
"FUNCTION","pgsodium","crypto_pwhash","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_pwhash(password bytea, salt bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_pwhash$function$
","null"
"FUNCTION","pgsodium","crypto_pwhash_saltgen","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_pwhash_saltgen()
 RETURNS bytea
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_crypto_pwhash_saltgen$function$
","null"
"FUNCTION","pgsodium","crypto_pwhash_str","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_pwhash_str(password bytea)
 RETURNS bytea
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_crypto_pwhash_str$function$
","null"
"FUNCTION","pgsodium","crypto_pwhash_str_verify","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_pwhash_str_verify(hashed_password bytea, password bytea)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_pwhash_str_verify$function$
","null"
"FUNCTION","pgsodium","crypto_secretbox","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_secretbox(message bytea, nonce bytea, key bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_secretbox$function$
","null"
"FUNCTION","pgsodium","crypto_secretbox","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_secretbox(message bytea, nonce bytea, key_id bigint, context bytea DEFAULT '\x7067736f6469756d'::bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_secretbox_by_id$function$
","null"
"FUNCTION","pgsodium","crypto_secretbox","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_secretbox(message bytea, nonce bytea, key_uuid uuid)
 RETURNS bytea
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  key pgsodium.decrypted_key;
BEGIN
  SELECT * INTO STRICT key
    FROM pgsodium.decrypted_key v
  WHERE id = key_uuid AND key_type = 'secretbox';

  IF key.decrypted_raw_key IS NOT NULL THEN
    RETURN pgsodium.crypto_secretbox(message, nonce, key.decrypted_raw_key);
  END IF;
  RETURN pgsodium.crypto_secretbox(message, nonce, key.key_id, key.key_context);
END;
$function$
","null"
"FUNCTION","pgsodium","crypto_secretbox_keygen","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_secretbox_keygen()
 RETURNS bytea
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_crypto_secretbox_keygen$function$
","null"
"FUNCTION","pgsodium","crypto_secretbox_noncegen","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_secretbox_noncegen()
 RETURNS bytea
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_crypto_secretbox_noncegen$function$
","null"
"FUNCTION","pgsodium","crypto_secretbox_open","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_secretbox_open(message bytea, nonce bytea, key_uuid uuid)
 RETURNS bytea
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  key pgsodium.decrypted_key;
BEGIN
  SELECT * INTO STRICT key
    FROM pgsodium.decrypted_key v
  WHERE id = key_uuid AND key_type = 'secretbox';

  IF key.decrypted_raw_key IS NOT NULL THEN
    RETURN pgsodium.crypto_secretbox_open(message, nonce, key.decrypted_raw_key);
  END IF;
  RETURN pgsodium.crypto_secretbox_open(message, nonce, key.key_id, key.key_context);
END;
$function$
","null"
"FUNCTION","pgsodium","crypto_secretbox_open","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_secretbox_open(message bytea, nonce bytea, key_id bigint, context bytea DEFAULT '\x7067736f6469756d'::bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_secretbox_open_by_id$function$
","null"
"FUNCTION","pgsodium","crypto_secretbox_open","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_secretbox_open(ciphertext bytea, nonce bytea, key bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_secretbox_open$function$
","null"
"FUNCTION","pgsodium","crypto_secretstream_keygen","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_secretstream_keygen()
 RETURNS bytea
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_crypto_secretstream_xchacha20poly1305_keygen$function$
","null"
"FUNCTION","pgsodium","crypto_shorthash","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_shorthash(message bytea, key bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_shorthash$function$
","null"
"FUNCTION","pgsodium","crypto_shorthash","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_shorthash(message bytea, key bigint, context bytea DEFAULT '\x7067736f6469756d'::bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_shorthash_by_id$function$
","null"
"FUNCTION","pgsodium","crypto_shorthash","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_shorthash(message bytea, key_uuid uuid)
 RETURNS bytea
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  key pgsodium.decrypted_key;
BEGIN
  SELECT * INTO STRICT key
    FROM pgsodium.decrypted_key v
  WHERE id = key_uuid AND key_type = 'shorthash';

  IF key.decrypted_raw_key IS NOT NULL THEN
    RETURN pgsodium.crypto_shorthash(message, key.decrypted_raw_key);
  END IF;
  RETURN pgsodium.crypto_shorthash(message, key.key_id, key.key_context);
END;

$function$
","null"
"FUNCTION","pgsodium","crypto_shorthash_keygen","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_shorthash_keygen()
 RETURNS bytea
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_crypto_shorthash_keygen$function$
","null"
"FUNCTION","pgsodium","crypto_sign","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_sign(message bytea, key bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_sign$function$
","null"
"FUNCTION","pgsodium","crypto_sign_detached","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_sign_detached(message bytea, key bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_sign_detached$function$
","null"
"FUNCTION","pgsodium","crypto_sign_final_create","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_sign_final_create(state bytea, key bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_sign_final_create$function$
","null"
"FUNCTION","pgsodium","crypto_sign_final_verify","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_sign_final_verify(state bytea, signature bytea, key bytea)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_sign_final_verify$function$
","null"
"FUNCTION","pgsodium","crypto_sign_init","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_sign_init()
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE STRICT
AS '$libdir/pgsodium', $function$pgsodium_crypto_sign_init$function$
","null"
"FUNCTION","pgsodium","crypto_sign_new_keypair","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_sign_new_keypair()
 RETURNS pgsodium.crypto_sign_keypair
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_crypto_sign_keypair$function$
","null"
"FUNCTION","pgsodium","crypto_sign_new_seed","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_sign_new_seed()
 RETURNS bytea
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_crypto_sign_new_seed$function$
","null"
"FUNCTION","pgsodium","crypto_sign_open","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_sign_open(signed_message bytea, key bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_sign_open$function$
","null"
"FUNCTION","pgsodium","crypto_sign_seed_new_keypair","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_sign_seed_new_keypair(seed bytea)
 RETURNS pgsodium.crypto_sign_keypair
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_sign_seed_keypair$function$
","null"
"FUNCTION","pgsodium","crypto_sign_update","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_sign_update(state bytea, message bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_sign_update$function$
","null"
"FUNCTION","pgsodium","crypto_sign_update_agg1","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_sign_update_agg1(state bytea, message bytea)
 RETURNS bytea
 LANGUAGE sql
 IMMUTABLE
AS $function$
 SELECT pgsodium.crypto_sign_update(COALESCE(state, pgsodium.crypto_sign_init()), message);
$function$
","Internal helper function for crypto_sign_update_agg(bytea). This
initializes state if it has not already been initialized."
"FUNCTION","pgsodium","crypto_sign_update_agg2","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_sign_update_agg2(cur_state bytea, initial_state bytea, message bytea)
 RETURNS bytea
 LANGUAGE sql
 IMMUTABLE
AS $function$
 SELECT pgsodium.crypto_sign_update(
       COALESCE(cur_state, initial_state),
	   message)
$function$
","Internal helper function for crypto_sign_update_agg(bytea, bytea). This
initializes state to the state passed to the aggregate as a parameter,
if it has not already been initialized."
"FUNCTION","pgsodium","crypto_sign_verify_detached","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_sign_verify_detached(sig bytea, message bytea, key bytea)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_sign_verify_detached$function$
","null"
"FUNCTION","pgsodium","crypto_signcrypt_new_keypair","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_signcrypt_new_keypair()
 RETURNS pgsodium.crypto_signcrypt_keypair
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_crypto_signcrypt_keypair$function$
","null"
"FUNCTION","pgsodium","crypto_signcrypt_sign_after","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_signcrypt_sign_after(state bytea, sender_sk bytea, ciphertext bytea)
 RETURNS bytea
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_crypto_signcrypt_sign_after$function$
","null"
"FUNCTION","pgsodium","crypto_signcrypt_sign_before","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_signcrypt_sign_before(sender bytea, recipient bytea, sender_sk bytea, recipient_pk bytea, additional bytea)
 RETURNS pgsodium.crypto_signcrypt_state_key
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_crypto_signcrypt_sign_before$function$
","null"
"FUNCTION","pgsodium","crypto_signcrypt_verify_after","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_signcrypt_verify_after(state bytea, signature bytea, sender_pk bytea, ciphertext bytea)
 RETURNS boolean
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_crypto_signcrypt_verify_after$function$
","null"
"FUNCTION","pgsodium","crypto_signcrypt_verify_before","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_signcrypt_verify_before(signature bytea, sender bytea, recipient bytea, additional bytea, sender_pk bytea, recipient_sk bytea)
 RETURNS pgsodium.crypto_signcrypt_state_key
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_crypto_signcrypt_verify_before$function$
","null"
"FUNCTION","pgsodium","crypto_signcrypt_verify_public","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_signcrypt_verify_public(signature bytea, sender bytea, recipient bytea, additional bytea, sender_pk bytea, ciphertext bytea)
 RETURNS boolean
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_crypto_signcrypt_verify_public$function$
","null"
"FUNCTION","pgsodium","crypto_stream_xchacha20","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_stream_xchacha20(bigint, bytea, bigint, context bytea DEFAULT '\x7067736f6469756d'::bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_stream_xchacha20_by_id$function$
","null"
"FUNCTION","pgsodium","crypto_stream_xchacha20","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_stream_xchacha20(bigint, bytea, bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_stream_xchacha20$function$
","null"
"FUNCTION","pgsodium","crypto_stream_xchacha20_keygen","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_stream_xchacha20_keygen()
 RETURNS bytea
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_crypto_stream_xchacha20_keygen$function$
","null"
"FUNCTION","pgsodium","crypto_stream_xchacha20_noncegen","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_stream_xchacha20_noncegen()
 RETURNS bytea
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_crypto_stream_xchacha20_noncegen$function$
","null"
"FUNCTION","pgsodium","crypto_stream_xchacha20_xor","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_stream_xchacha20_xor(bytea, bytea, bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_stream_xchacha20_xor$function$
","null"
"FUNCTION","pgsodium","crypto_stream_xchacha20_xor","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_stream_xchacha20_xor(bytea, bytea, bigint, context bytea DEFAULT '\x70676f736469756d'::bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_stream_xchacha20_xor_by_id$function$
","null"
"FUNCTION","pgsodium","crypto_stream_xchacha20_xor_ic","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_stream_xchacha20_xor_ic(bytea, bytea, bigint, bigint, context bytea DEFAULT '\x7067736f6469756d'::bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_stream_xchacha20_xor_ic_by_id$function$
","null"
"FUNCTION","pgsodium","crypto_stream_xchacha20_xor_ic","null","CREATE OR REPLACE FUNCTION pgsodium.crypto_stream_xchacha20_xor_ic(bytea, bytea, bigint, bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_crypto_stream_xchacha20_xor_ic$function$
","null"
"FUNCTION","pgsodium","decrypted_columns","null","CREATE OR REPLACE FUNCTION pgsodium.decrypted_columns(relid oid)
 RETURNS text
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
DECLARE
  m RECORD;
  expression TEXT;
  comma TEXT;
  padding text = '        ';
BEGIN
  expression := E'\n';
  comma := padding;
  FOR m IN SELECT * FROM pgsodium.mask_columns where attrelid = relid LOOP
    expression := expression || comma;
    IF m.key_id IS NULL AND m.key_id_column IS NULL THEN
      expression := expression || padding || quote_ident(m.attname);
    ELSE
      expression := expression || padding || quote_ident(m.attname) || E',\n';
      IF m.format_type = 'text' THEN
          expression := expression || format(
            $f$
            CASE WHEN %s IS NULL THEN NULL ELSE
                CASE WHEN %s IS NULL THEN NULL ELSE pg_catalog.convert_from(
                  pgsodium.crypto_aead_det_decrypt(
                    pg_catalog.decode(%s, 'base64'),
                    pg_catalog.convert_to((%s)::text, 'utf8'),
                    %s::uuid,
                    %s
                  ),
                    'utf8') END
                END AS %s$f$,
                quote_ident(m.attname),
                coalesce(quote_ident(m.key_id_column), quote_literal(m.key_id)),
                quote_ident(m.attname),
                coalesce(pgsodium.quote_assoc(m.associated_columns), quote_literal('')),
                coalesce(quote_ident(m.key_id_column), quote_literal(m.key_id)),
                coalesce(quote_ident(m.nonce_column), 'NULL'),
                quote_ident('decrypted_' || m.attname)
          );
      ELSIF m.format_type = 'bytea' THEN
          expression := expression || format(
            $f$
            CASE WHEN %s IS NULL THEN NULL ELSE
                CASE WHEN %s IS NULL THEN NULL ELSE pgsodium.crypto_aead_det_decrypt(
                    %s::bytea,
                    pg_catalog.convert_to((%s)::text, 'utf8'),
                    %s::uuid,
                    %s
                  ) END
                END AS %s$f$,
                quote_ident(m.attname),
                coalesce(quote_ident(m.key_id_column), quote_literal(m.key_id)),
                quote_ident(m.attname),
                coalesce(pgsodium.quote_assoc(m.associated_columns), quote_literal('')),
                coalesce(quote_ident(m.key_id_column), quote_literal(m.key_id)),
                coalesce(quote_ident(m.nonce_column), 'NULL'),
                'decrypted_' || quote_ident(m.attname)
          );
      END IF;
    END IF;
    comma := E',       \n';
  END LOOP;
  RETURN expression;
END
$function$
","null"
"FUNCTION","pgsodium","derive_key","null","CREATE OR REPLACE FUNCTION pgsodium.derive_key(key_id bigint, key_len integer DEFAULT 32, context bytea DEFAULT '\x7067736f6469756d'::bytea)
 RETURNS bytea
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_derive$function$
","null"
"FUNCTION","pgsodium","disable_security_label_trigger","null","CREATE OR REPLACE FUNCTION pgsodium.disable_security_label_trigger()
 RETURNS void
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
    ALTER EVENT TRIGGER pgsodium_trg_mask_update DISABLE;
  $function$
","null"
"FUNCTION","pgsodium","enable_security_label_trigger","null","CREATE OR REPLACE FUNCTION pgsodium.enable_security_label_trigger()
 RETURNS void
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
    ALTER EVENT TRIGGER pgsodium_trg_mask_update ENABLE;
  $function$
","null"
"FUNCTION","pgsodium","encrypted_column","null","CREATE OR REPLACE FUNCTION pgsodium.encrypted_column(relid oid, m record)
 RETURNS text
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
DECLARE
    expression TEXT;
    comma TEXT;
BEGIN
  expression := '';
  comma := E'        ';
  expression := expression || comma;
  IF m.format_type = 'text' THEN
	  expression := expression || format(
		$f$%s = CASE WHEN %s IS NULL THEN NULL ELSE
			CASE WHEN %s IS NULL THEN NULL ELSE pg_catalog.encode(
			  pgsodium.crypto_aead_det_encrypt(
				pg_catalog.convert_to(%s, 'utf8'),
				pg_catalog.convert_to((%s)::text, 'utf8'),
				%s::uuid,
				%s
			  ),
				'base64') END END$f$,
			'new.' || quote_ident(m.attname),
			'new.' || quote_ident(m.attname),
			COALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),
			'new.' || quote_ident(m.attname),
			COALESCE(pgsodium.quote_assoc(m.associated_columns, true), quote_literal('')),
			COALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),
			COALESCE('new.' || quote_ident(m.nonce_column), 'NULL')
	  );
  ELSIF m.format_type = 'bytea' THEN
	  expression := expression || format(
		$f$%s = CASE WHEN %s IS NULL THEN NULL ELSE
			CASE WHEN %s IS NULL THEN NULL ELSE
					pgsodium.crypto_aead_det_encrypt(%s::bytea, pg_catalog.convert_to((%s)::text, 'utf8'),
			%s::uuid,
			%s
		  ) END END$f$,
			'new.' || quote_ident(m.attname),
			'new.' || quote_ident(m.attname),
			COALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),
			'new.' || quote_ident(m.attname),
			COALESCE(pgsodium.quote_assoc(m.associated_columns, true), quote_literal('')),
			COALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),
			COALESCE('new.' || quote_ident(m.nonce_column), 'NULL')
	  );
  END IF;
  comma := E';\n        ';
  RETURN expression;
END
$function$
","null"
"FUNCTION","pgsodium","encrypted_columns","null","CREATE OR REPLACE FUNCTION pgsodium.encrypted_columns(relid oid)
 RETURNS text
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
DECLARE
    m RECORD;
    expression TEXT;
    comma TEXT;
BEGIN
  expression := '';
  comma := E'        ';
  FOR m IN SELECT * FROM pgsodium.mask_columns where attrelid = relid LOOP
    IF m.key_id IS NULL AND m.key_id_column is NULL THEN
      CONTINUE;
    ELSE
      expression := expression || comma;
      IF m.format_type = 'text' THEN
          expression := expression || format(
            $f$%s = CASE WHEN %s IS NULL THEN NULL ELSE
                CASE WHEN %s IS NULL THEN NULL ELSE pg_catalog.encode(
                  pgsodium.crypto_aead_det_encrypt(
                    pg_catalog.convert_to(%s, 'utf8'),
                    pg_catalog.convert_to((%s)::text, 'utf8'),
                    %s::uuid,
                    %s
                  ),
                    'base64') END END$f$,
                'new.' || quote_ident(m.attname),
                'new.' || quote_ident(m.attname),
                COALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),
                'new.' || quote_ident(m.attname),
                COALESCE(pgsodium.quote_assoc(m.associated_columns, true), quote_literal('')),
                COALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),
                COALESCE('new.' || quote_ident(m.nonce_column), 'NULL')
          );
      ELSIF m.format_type = 'bytea' THEN
          expression := expression || format(
            $f$%s = CASE WHEN %s IS NULL THEN NULL ELSE
                CASE WHEN %s IS NULL THEN NULL ELSE
                        pgsodium.crypto_aead_det_encrypt(%s::bytea, pg_catalog.convert_to((%s)::text, 'utf8'),
                %s::uuid,
                %s
              ) END END$f$,
                'new.' || quote_ident(m.attname),
                'new.' || quote_ident(m.attname),
                COALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),
                'new.' || quote_ident(m.attname),
                COALESCE(pgsodium.quote_assoc(m.associated_columns, true), quote_literal('')),
                COALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),
                COALESCE('new.' || quote_ident(m.nonce_column), 'NULL')
          );
      END IF;
    END IF;
    comma := E';\n        ';
  END LOOP;
  RETURN expression;
END
$function$
","null"
"FUNCTION","pgsodium","get_key_by_id","null","CREATE OR REPLACE FUNCTION pgsodium.get_key_by_id(uuid)
 RETURNS pgsodium.valid_key
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
    SELECT * from pgsodium.valid_key WHERE id = $1;
$function$
","null"
"FUNCTION","pgsodium","get_key_by_name","null","CREATE OR REPLACE FUNCTION pgsodium.get_key_by_name(text)
 RETURNS pgsodium.valid_key
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
    SELECT * from pgsodium.valid_key WHERE name = $1;
$function$
","null"
"FUNCTION","pgsodium","get_named_keys","null","CREATE OR REPLACE FUNCTION pgsodium.get_named_keys(filter text DEFAULT '%'::text)
 RETURNS SETOF pgsodium.valid_key
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
    SELECT * from pgsodium.valid_key vk WHERE vk.name ILIKE filter;
$function$
","null"
"FUNCTION","pgsodium","has_mask","null","CREATE OR REPLACE FUNCTION pgsodium.has_mask(role regrole, source_name text)
 RETURNS boolean
 LANGUAGE sql
AS $function$
  SELECT EXISTS(
    SELECT 1
      FROM pg_shseclabel
     WHERE  objoid = role
       AND provider = 'pgsodium'
       AND label ilike 'ACCESS%' || source_name || '%')
  $function$
","null"
"FUNCTION","pgsodium","key_encrypt_secret_raw_key","null","CREATE OR REPLACE FUNCTION pgsodium.key_encrypt_secret_raw_key()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
		BEGIN
		        new.raw_key = CASE WHEN new.raw_key IS NULL THEN NULL ELSE
			CASE WHEN new.parent_key IS NULL THEN NULL ELSE
					pgsodium.crypto_aead_det_encrypt(new.raw_key::bytea, pg_catalog.convert_to((new.id::text || new.associated_data::text)::text, 'utf8'),
			new.parent_key::uuid,
			new.raw_key_nonce
		  ) END END;
		RETURN new;
		END;
		$function$
","null"
"FUNCTION","pgsodium","mask_columns","null","CREATE OR REPLACE FUNCTION pgsodium.mask_columns(source_relid oid)
 RETURNS TABLE(attname name, key_id text, key_id_column text, associated_column text, nonce_column text, format_type text)
 LANGUAGE sql
AS $function$
  SELECT
  a.attname,
  m.key_id,
  m.key_id_column,
  m.associated_column,
  m.nonce_column,
  m.format_type
  FROM pg_attribute a
  LEFT JOIN  pgsodium.masking_rule m
  ON m.attrelid = a.attrelid
  AND m.attname = a.attname
  WHERE  a.attrelid = source_relid
  AND    a.attnum > 0 -- exclude ctid, cmin, cmax
  AND    NOT a.attisdropped
  ORDER BY a.attnum;
$function$
","null"
"FUNCTION","pgsodium","mask_role","null","CREATE OR REPLACE FUNCTION pgsodium.mask_role(masked_role regrole, source_name text, view_name text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
    BEGIN
      EXECUTE format(
        'GRANT SELECT ON pgsodium.key TO %s',
        masked_role);

      EXECUTE format(
        'GRANT pgsodium_keyiduser, pgsodium_keyholder TO %s',
        masked_role);

      EXECUTE format(
        'GRANT ALL ON %I TO %s',
        view_name,
        masked_role);
      RETURN;
    END
    $function$
","null"
"FUNCTION","pgsodium","pgsodium_derive","null","CREATE OR REPLACE FUNCTION pgsodium.pgsodium_derive(key_id bigint, key_len integer DEFAULT 32, context bytea DEFAULT decode('pgsodium'::text, 'escape'::text))
 RETURNS bytea
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_derive$function$
","null"
"FUNCTION","pgsodium","quote_assoc","null","CREATE OR REPLACE FUNCTION pgsodium.quote_assoc(text, boolean DEFAULT false)
 RETURNS text
 LANGUAGE sql
AS $function$
    WITH a AS (SELECT array_agg(CASE WHEN $2 THEN
                                    'new.' || quote_ident(trim(v))
                                ELSE quote_ident(trim(v)) END) as r
               FROM regexp_split_to_table($1, '\s*,\s*') as v)
    SELECT array_to_string(a.r, '::text || ') || '::text' FROM a;
$function$
","null"
"FUNCTION","pgsodium","randombytes_buf","null","CREATE OR REPLACE FUNCTION pgsodium.randombytes_buf(size integer)
 RETURNS bytea
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_randombytes_buf$function$
","null"
"FUNCTION","pgsodium","randombytes_buf_deterministic","null","CREATE OR REPLACE FUNCTION pgsodium.randombytes_buf_deterministic(size integer, seed bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_randombytes_buf_deterministic$function$
","null"
"FUNCTION","pgsodium","randombytes_new_seed","null","CREATE OR REPLACE FUNCTION pgsodium.randombytes_new_seed()
 RETURNS bytea
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_randombytes_new_seed$function$
","null"
"FUNCTION","pgsodium","randombytes_random","null","CREATE OR REPLACE FUNCTION pgsodium.randombytes_random()
 RETURNS integer
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_randombytes_random$function$
","null"
"FUNCTION","pgsodium","randombytes_uniform","null","CREATE OR REPLACE FUNCTION pgsodium.randombytes_uniform(upper_bound integer)
 RETURNS integer
 LANGUAGE c
AS '$libdir/pgsodium', $function$pgsodium_randombytes_uniform$function$
","null"
"FUNCTION","pgsodium","sodium_base642bin","null","CREATE OR REPLACE FUNCTION pgsodium.sodium_base642bin(base64 text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_sodium_base642bin$function$
","null"
"FUNCTION","pgsodium","sodium_bin2base64","null","CREATE OR REPLACE FUNCTION pgsodium.sodium_bin2base64(bin bytea)
 RETURNS text
 LANGUAGE c
 IMMUTABLE
AS '$libdir/pgsodium', $function$pgsodium_sodium_bin2base64$function$
","null"
"FUNCTION","pgsodium","trg_mask_update","null","CREATE OR REPLACE FUNCTION pgsodium.trg_mask_update()
 RETURNS event_trigger
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
DECLARE
  r record;
BEGIN
  IF (SELECT bool_or(in_extension) FROM pg_event_trigger_ddl_commands()) THEN
    RAISE NOTICE 'skipping pgsodium mask regeneration in extension';
	RETURN;
  END IF;

  FOR r IN
    SELECT e.*
    FROM pg_event_trigger_ddl_commands() e
    WHERE EXISTS (
      SELECT FROM pg_catalog.pg_class c
      JOIN pg_catalog.pg_seclabel s ON s.classoid = c.tableoid
                                   AND s.objoid = c.oid
      WHERE c.tableoid = e.classid
        AND e.objid = c.oid
        AND s.provider = 'pgsodium'
    )
  LOOP
    IF r.object_type in ('table', 'table column')
    THEN
      PERFORM pgsodium.update_mask(r.objid);
    END IF;
  END LOOP;
END
$function$
","null"
"FUNCTION","pgsodium","update_mask","null","CREATE OR REPLACE FUNCTION pgsodium.update_mask(target oid, debug boolean DEFAULT false)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
BEGIN
  PERFORM pgsodium.disable_security_label_trigger();
  PERFORM pgsodium.create_mask_view(objoid, objsubid, debug)
    FROM pg_catalog.pg_seclabel sl
    WHERE sl.objoid = target
      AND sl.label ILIKE 'ENCRYPT%'
      AND sl.provider = 'pgsodium';
  PERFORM pgsodium.enable_security_label_trigger();
  RETURN;
END
$function$
","null"
"FUNCTION","pgsodium","update_masks","null","CREATE OR REPLACE FUNCTION pgsodium.update_masks(debug boolean DEFAULT false)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
BEGIN
  PERFORM pgsodium.update_mask(objoid, debug)
    FROM pg_catalog.pg_seclabel sl
    JOIN pg_catalog.pg_class cl ON (cl.oid = sl.objoid)
    WHERE label ilike 'ENCRYPT%'
       AND cl.relowner = session_user::regrole::oid
       AND provider = 'pgsodium'
	   AND objoid::regclass != 'pgsodium.key'::regclass
	;
  RETURN;
END
$function$
","null"
"FUNCTION","pgsodium","version","null","CREATE OR REPLACE FUNCTION pgsodium.version()
 RETURNS text
 LANGUAGE sql
AS $function$ SELECT extversion FROM pg_extension WHERE extname = 'pgsodium' $function$
","null"
"FUNCTION","public","handle_new_user","null","CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  -- Insert a row into public users table
  INSERT INTO public.users (
    id,
    email,
    username,
    full_name,
    avatar_url,
    theme,
    privacy_settings,
    created_at,
    updated_at
  ) VALUES (
    NEW.id,
    NEW.email,
    LOWER(SPLIT_PART(NEW.email, '@', 1)), -- Generate username from email
    COALESCE(NEW.raw_user_meta_data->>'full_name', SPLIT_PART(NEW.email, '@', 1)), -- Use name or generate from email
    COALESCE(NEW.raw_user_meta_data->>'avatar_url', NULL),
    'light', -- Default theme
    '{"posts_visibility": "public", "profile_visibility": "public"}'::jsonb, -- Default privacy settings
    NOW(),
    NOW()
  );
  RETURN NEW;
END;
$function$
","null"
"FUNCTION","public","handle_user_delete","null","CREATE OR REPLACE FUNCTION public.handle_user_delete()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  -- Delete the user from auth.users
  DELETE FROM auth.users WHERE id = OLD.id;
  RETURN OLD;
END;
$function$
","null"
"FUNCTION","public","posts_search_update","null","CREATE OR REPLACE FUNCTION public.posts_search_update()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.search_vector := 
    setweight(to_tsvector('english', COALESCE(NEW.content, '')), 'A');
  RETURN NEW;
END
$function$
","null"
"FUNCTION","realtime","apply_rls","null","CREATE OR REPLACE FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer DEFAULT (1024 * 1024))
 RETURNS SETOF realtime.wal_rls
 LANGUAGE plpgsql
AS $function$
declare
-- Regclass of the table e.g. public.notes
entity_ regclass = (quote_ident(wal ->> 'schema') || '.' || quote_ident(wal ->> 'table'))::regclass;

-- I, U, D, T: insert, update ...
action realtime.action = (
    case wal ->> 'action'
        when 'I' then 'INSERT'
        when 'U' then 'UPDATE'
        when 'D' then 'DELETE'
        else 'ERROR'
    end
);

-- Is row level security enabled for the table
is_rls_enabled bool = relrowsecurity from pg_class where oid = entity_;

subscriptions realtime.subscription[] = array_agg(subs)
    from
        realtime.subscription subs
    where
        subs.entity = entity_;

-- Subscription vars
roles regrole[] = array_agg(distinct us.claims_role::text)
    from
        unnest(subscriptions) us;

working_role regrole;
claimed_role regrole;
claims jsonb;

subscription_id uuid;
subscription_has_access bool;
visible_to_subscription_ids uuid[] = '{}';

-- structured info for wal's columns
columns realtime.wal_column[];
-- previous identity values for update/delete
old_columns realtime.wal_column[];

error_record_exceeds_max_size boolean = octet_length(wal::text) > max_record_bytes;

-- Primary jsonb output for record
output jsonb;

begin
perform set_config('role', null, true);

columns =
    array_agg(
        (
            x->>'name',
            x->>'type',
            x->>'typeoid',
            realtime.cast(
                (x->'value') #>> '{}',
                coalesce(
                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4
                    (x->>'type')::regtype
                )
            ),
            (pks ->> 'name') is not null,
            true
        )::realtime.wal_column
    )
    from
        jsonb_array_elements(wal -> 'columns') x
        left join jsonb_array_elements(wal -> 'pk') pks
            on (x ->> 'name') = (pks ->> 'name');

old_columns =
    array_agg(
        (
            x->>'name',
            x->>'type',
            x->>'typeoid',
            realtime.cast(
                (x->'value') #>> '{}',
                coalesce(
                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4
                    (x->>'type')::regtype
                )
            ),
            (pks ->> 'name') is not null,
            true
        )::realtime.wal_column
    )
    from
        jsonb_array_elements(wal -> 'identity') x
        left join jsonb_array_elements(wal -> 'pk') pks
            on (x ->> 'name') = (pks ->> 'name');

for working_role in select * from unnest(roles) loop

    -- Update `is_selectable` for columns and old_columns
    columns =
        array_agg(
            (
                c.name,
                c.type_name,
                c.type_oid,
                c.value,
                c.is_pkey,
                pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')
            )::realtime.wal_column
        )
        from
            unnest(columns) c;

    old_columns =
            array_agg(
                (
                    c.name,
                    c.type_name,
                    c.type_oid,
                    c.value,
                    c.is_pkey,
                    pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')
                )::realtime.wal_column
            )
            from
                unnest(old_columns) c;

    if action <> 'DELETE' and count(1) = 0 from unnest(columns) c where c.is_pkey then
        return next (
            jsonb_build_object(
                'schema', wal ->> 'schema',
                'table', wal ->> 'table',
                'type', action
            ),
            is_rls_enabled,
            -- subscriptions is already filtered by entity
            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),
            array['Error 400: Bad Request, no primary key']
        )::realtime.wal_rls;

    -- The claims role does not have SELECT permission to the primary key of entity
    elsif action <> 'DELETE' and sum(c.is_selectable::int) <> count(1) from unnest(columns) c where c.is_pkey then
        return next (
            jsonb_build_object(
                'schema', wal ->> 'schema',
                'table', wal ->> 'table',
                'type', action
            ),
            is_rls_enabled,
            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),
            array['Error 401: Unauthorized']
        )::realtime.wal_rls;

    else
        output = jsonb_build_object(
            'schema', wal ->> 'schema',
            'table', wal ->> 'table',
            'type', action,
            'commit_timestamp', to_char(
                ((wal ->> 'timestamp')::timestamptz at time zone 'utc'),
                'YYYY-MM-DD"T"HH24:MI:SS.MS"Z"'
            ),
            'columns', (
                select
                    jsonb_agg(
                        jsonb_build_object(
                            'name', pa.attname,
                            'type', pt.typname
                        )
                        order by pa.attnum asc
                    )
                from
                    pg_attribute pa
                    join pg_type pt
                        on pa.atttypid = pt.oid
                where
                    attrelid = entity_
                    and attnum > 0
                    and pg_catalog.has_column_privilege(working_role, entity_, pa.attname, 'SELECT')
            )
        )
        -- Add "record" key for insert and update
        || case
            when action in ('INSERT', 'UPDATE') then
                jsonb_build_object(
                    'record',
                    (
                        select
                            jsonb_object_agg(
                                -- if unchanged toast, get column name and value from old record
                                coalesce((c).name, (oc).name),
                                case
                                    when (c).name is null then (oc).value
                                    else (c).value
                                end
                            )
                        from
                            unnest(columns) c
                            full outer join unnest(old_columns) oc
                                on (c).name = (oc).name
                        where
                            coalesce((c).is_selectable, (oc).is_selectable)
                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))
                    )
                )
            else '{}'::jsonb
        end
        -- Add "old_record" key for update and delete
        || case
            when action = 'UPDATE' then
                jsonb_build_object(
                        'old_record',
                        (
                            select jsonb_object_agg((c).name, (c).value)
                            from unnest(old_columns) c
                            where
                                (c).is_selectable
                                and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))
                        )
                    )
            when action = 'DELETE' then
                jsonb_build_object(
                    'old_record',
                    (
                        select jsonb_object_agg((c).name, (c).value)
                        from unnest(old_columns) c
                        where
                            (c).is_selectable
                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))
                            and ( not is_rls_enabled or (c).is_pkey ) -- if RLS enabled, we can't secure deletes so filter to pkey
                    )
                )
            else '{}'::jsonb
        end;

        -- Create the prepared statement
        if is_rls_enabled and action <> 'DELETE' then
            if (select 1 from pg_prepared_statements where name = 'walrus_rls_stmt' limit 1) > 0 then
                deallocate walrus_rls_stmt;
            end if;
            execute realtime.build_prepared_statement_sql('walrus_rls_stmt', entity_, columns);
        end if;

        visible_to_subscription_ids = '{}';

        for subscription_id, claims in (
                select
                    subs.subscription_id,
                    subs.claims
                from
                    unnest(subscriptions) subs
                where
                    subs.entity = entity_
                    and subs.claims_role = working_role
                    and (
                        realtime.is_visible_through_filters(columns, subs.filters)
                        or (
                          action = 'DELETE'
                          and realtime.is_visible_through_filters(old_columns, subs.filters)
                        )
                    )
        ) loop

            if not is_rls_enabled or action = 'DELETE' then
                visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;
            else
                -- Check if RLS allows the role to see the record
                perform
                    -- Trim leading and trailing quotes from working_role because set_config
                    -- doesn't recognize the role as valid if they are included
                    set_config('role', trim(both '"' from working_role::text), true),
                    set_config('request.jwt.claims', claims::text, true);

                execute 'execute walrus_rls_stmt' into subscription_has_access;

                if subscription_has_access then
                    visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;
                end if;
            end if;
        end loop;

        perform set_config('role', null, true);

        return next (
            output,
            is_rls_enabled,
            visible_to_subscription_ids,
            case
                when error_record_exceeds_max_size then array['Error 413: Payload Too Large']
                else '{}'
            end
        )::realtime.wal_rls;

    end if;
end loop;

perform set_config('role', null, true);
end;
$function$
","null"
"FUNCTION","realtime","broadcast_changes","null","CREATE OR REPLACE FUNCTION realtime.broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text DEFAULT 'ROW'::text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    -- Declare a variable to hold the JSONB representation of the row
    row_data jsonb := '{}'::jsonb;
BEGIN
    IF level = 'STATEMENT' THEN
        RAISE EXCEPTION 'function can only be triggered for each row, not for each statement';
    END IF;
    -- Check the operation type and handle accordingly
    IF operation = 'INSERT' OR operation = 'UPDATE' OR operation = 'DELETE' THEN
        row_data := jsonb_build_object('old_record', OLD, 'record', NEW, 'operation', operation, 'table', table_name, 'schema', table_schema);
        PERFORM realtime.send (row_data, event_name, topic_name);
    ELSE
        RAISE EXCEPTION 'Unexpected operation type: %', operation;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Failed to process the row: %', SQLERRM;
END;

$function$
","null"
"FUNCTION","realtime","build_prepared_statement_sql","null","CREATE OR REPLACE FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[])
 RETURNS text
 LANGUAGE sql
AS $function$
      /*
      Builds a sql string that, if executed, creates a prepared statement to
      tests retrive a row from *entity* by its primary key columns.
      Example
          select realtime.build_prepared_statement_sql('public.notes', '{"id"}'::text[], '{"bigint"}'::text[])
      */
          select
      'prepare ' || prepared_statement_name || ' as
          select
              exists(
                  select
                      1
                  from
                      ' || entity || '
                  where
                      ' || string_agg(quote_ident(pkc.name) || '=' || quote_nullable(pkc.value #>> '{}') , ' and ') || '
              )'
          from
              unnest(columns) pkc
          where
              pkc.is_pkey
          group by
              entity
      $function$
","null"
"FUNCTION","realtime","cast","null","CREATE OR REPLACE FUNCTION realtime."cast"(val text, type_ regtype)
 RETURNS jsonb
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
    declare
      res jsonb;
    begin
      execute format('select to_jsonb(%L::'|| type_::text || ')', val)  into res;
      return res;
    end
    $function$
","null"
"FUNCTION","realtime","check_equality_op","null","CREATE OR REPLACE FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text)
 RETURNS boolean
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
      /*
      Casts *val_1* and *val_2* as type *type_* and check the *op* condition for truthiness
      */
      declare
          op_symbol text = (
              case
                  when op = 'eq' then '='
                  when op = 'neq' then '!='
                  when op = 'lt' then '<'
                  when op = 'lte' then '<='
                  when op = 'gt' then '>'
                  when op = 'gte' then '>='
                  when op = 'in' then '= any'
                  else 'UNKNOWN OP'
              end
          );
          res boolean;
      begin
          execute format(
              'select %L::'|| type_::text || ' ' || op_symbol
              || ' ( %L::'
              || (
                  case
                      when op = 'in' then type_::text || '[]'
                      else type_::text end
              )
              || ')', val_1, val_2) into res;
          return res;
      end;
      $function$
","null"
"FUNCTION","realtime","is_visible_through_filters","null","CREATE OR REPLACE FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[])
 RETURNS boolean
 LANGUAGE sql
 IMMUTABLE
AS $function$
    /*
    Should the record be visible (true) or filtered out (false) after *filters* are applied
    */
        select
            -- Default to allowed when no filters present
            $2 is null -- no filters. this should not happen because subscriptions has a default
            or array_length($2, 1) is null -- array length of an empty array is null
            or bool_and(
                coalesce(
                    realtime.check_equality_op(
                        op:=f.op,
                        type_:=coalesce(
                            col.type_oid::regtype, -- null when wal2json version <= 2.4
                            col.type_name::regtype
                        ),
                        -- cast jsonb to text
                        val_1:=col.value #>> '{}',
                        val_2:=f.value
                    ),
                    false -- if null, filter does not match
                )
            )
        from
            unnest(filters) f
            join unnest(columns) col
                on f.column_name = col.name;
    $function$
","null"
"FUNCTION","realtime","list_changes","null","CREATE OR REPLACE FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer)
 RETURNS SETOF realtime.wal_rls
 LANGUAGE sql
 SET log_min_messages TO 'fatal'
AS $function$
      with pub as (
        select
          concat_ws(
            ',',
            case when bool_or(pubinsert) then 'insert' else null end,
            case when bool_or(pubupdate) then 'update' else null end,
            case when bool_or(pubdelete) then 'delete' else null end
          ) as w2j_actions,
          coalesce(
            string_agg(
              realtime.quote_wal2json(format('%I.%I', schemaname, tablename)::regclass),
              ','
            ) filter (where ppt.tablename is not null and ppt.tablename not like '% %'),
            ''
          ) w2j_add_tables
        from
          pg_publication pp
          left join pg_publication_tables ppt
            on pp.pubname = ppt.pubname
        where
          pp.pubname = publication
        group by
          pp.pubname
        limit 1
      ),
      w2j as (
        select
          x.*, pub.w2j_add_tables
        from
          pub,
          pg_logical_slot_get_changes(
            slot_name, null, max_changes,
            'include-pk', 'true',
            'include-transaction', 'false',
            'include-timestamp', 'true',
            'include-type-oids', 'true',
            'format-version', '2',
            'actions', pub.w2j_actions,
            'add-tables', pub.w2j_add_tables
          ) x
      )
      select
        xyz.wal,
        xyz.is_rls_enabled,
        xyz.subscription_ids,
        xyz.errors
      from
        w2j,
        realtime.apply_rls(
          wal := w2j.data::jsonb,
          max_record_bytes := max_record_bytes
        ) xyz(wal, is_rls_enabled, subscription_ids, errors)
      where
        w2j.w2j_add_tables <> ''
        and xyz.subscription_ids[1] is not null
    $function$
","null"
"FUNCTION","realtime","quote_wal2json","null","CREATE OR REPLACE FUNCTION realtime.quote_wal2json(entity regclass)
 RETURNS text
 LANGUAGE sql
 IMMUTABLE STRICT
AS $function$
      select
        (
          select string_agg('' || ch,'')
          from unnest(string_to_array(nsp.nspname::text, null)) with ordinality x(ch, idx)
          where
            not (x.idx = 1 and x.ch = '"')
            and not (
              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)
              and x.ch = '"'
            )
        )
        || '.'
        || (
          select string_agg('' || ch,'')
          from unnest(string_to_array(pc.relname::text, null)) with ordinality x(ch, idx)
          where
            not (x.idx = 1 and x.ch = '"')
            and not (
              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)
              and x.ch = '"'
            )
          )
      from
        pg_class pc
        join pg_namespace nsp
          on pc.relnamespace = nsp.oid
      where
        pc.oid = entity
    $function$
","null"
"FUNCTION","realtime","send","null","CREATE OR REPLACE FUNCTION realtime.send(payload jsonb, event text, topic text, private boolean DEFAULT true)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  BEGIN
    -- Set the topic configuration
    EXECUTE format('SET LOCAL realtime.topic TO %L', topic);

    -- Attempt to insert the message
    INSERT INTO realtime.messages (payload, event, topic, private, extension)
    VALUES (payload, event, topic, private, 'broadcast');
  EXCEPTION
    WHEN OTHERS THEN
      -- Capture and notify the error
      PERFORM pg_notify(
          'realtime:system',
          jsonb_build_object(
              'error', SQLERRM,
              'function', 'realtime.send',
              'event', event,
              'topic', topic,
              'private', private
          )::text
      );
  END;
END;
$function$
","null"
"FUNCTION","realtime","subscription_check_filters","null","CREATE OR REPLACE FUNCTION realtime.subscription_check_filters()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
    /*
    Validates that the user defined filters for a subscription:
    - refer to valid columns that the claimed role may access
    - values are coercable to the correct column type
    */
    declare
        col_names text[] = coalesce(
                array_agg(c.column_name order by c.ordinal_position),
                '{}'::text[]
            )
            from
                information_schema.columns c
            where
                format('%I.%I', c.table_schema, c.table_name)::regclass = new.entity
                and pg_catalog.has_column_privilege(
                    (new.claims ->> 'role'),
                    format('%I.%I', c.table_schema, c.table_name)::regclass,
                    c.column_name,
                    'SELECT'
                );
        filter realtime.user_defined_filter;
        col_type regtype;

        in_val jsonb;
    begin
        for filter in select * from unnest(new.filters) loop
            -- Filtered column is valid
            if not filter.column_name = any(col_names) then
                raise exception 'invalid column for filter %', filter.column_name;
            end if;

            -- Type is sanitized and safe for string interpolation
            col_type = (
                select atttypid::regtype
                from pg_catalog.pg_attribute
                where attrelid = new.entity
                      and attname = filter.column_name
            );
            if col_type is null then
                raise exception 'failed to lookup type for column %', filter.column_name;
            end if;

            -- Set maximum number of entries for in filter
            if filter.op = 'in'::realtime.equality_op then
                in_val = realtime.cast(filter.value, (col_type::text || '[]')::regtype);
                if coalesce(jsonb_array_length(in_val), 0) > 100 then
                    raise exception 'too many values for `in` filter. Maximum 100';
                end if;
            else
                -- raises an exception if value is not coercable to type
                perform realtime.cast(filter.value, col_type);
            end if;

        end loop;

        -- Apply consistent order to filters so the unique constraint on
        -- (subscription_id, entity, filters) can't be tricked by a different filter order
        new.filters = coalesce(
            array_agg(f order by f.column_name, f.op, f.value),
            '{}'
        ) from unnest(new.filters) f;

        return new;
    end;
    $function$
","null"
"FUNCTION","realtime","to_regrole","null","CREATE OR REPLACE FUNCTION realtime.to_regrole(role_name text)
 RETURNS regrole
 LANGUAGE sql
 IMMUTABLE
AS $function$ select role_name::regrole $function$
","null"
"FUNCTION","realtime","topic","null","CREATE OR REPLACE FUNCTION realtime.topic()
 RETURNS text
 LANGUAGE sql
 STABLE
AS $function$
select nullif(current_setting('realtime.topic', true), '')::text;
$function$
","null"
"FUNCTION","storage","can_insert_object","null","CREATE OR REPLACE FUNCTION storage.can_insert_object(bucketid text, name text, owner uuid, metadata jsonb)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  INSERT INTO "storage"."objects" ("bucket_id", "name", "owner", "metadata") VALUES (bucketid, name, owner, metadata);
  -- hack to rollback the successful insert
  RAISE sqlstate 'PT200' using
  message = 'ROLLBACK',
  detail = 'rollback successful insert';
END
$function$
","null"
"FUNCTION","storage","extension","null","CREATE OR REPLACE FUNCTION storage.extension(name text)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
_parts text[];
_filename text;
BEGIN
	select string_to_array(name, '/') into _parts;
	select _parts[array_length(_parts,1)] into _filename;
	-- @todo return the last part instead of 2
	return reverse(split_part(reverse(_filename), '.', 1));
END
$function$
","null"
"FUNCTION","storage","filename","null","CREATE OR REPLACE FUNCTION storage.filename(name text)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
_parts text[];
BEGIN
	select string_to_array(name, '/') into _parts;
	return _parts[array_length(_parts,1)];
END
$function$
","null"
"FUNCTION","storage","foldername","null","CREATE OR REPLACE FUNCTION storage.foldername(name text)
 RETURNS text[]
 LANGUAGE plpgsql
AS $function$
DECLARE
_parts text[];
BEGIN
	select string_to_array(name, '/') into _parts;
	return _parts[1:array_length(_parts,1)-1];
END
$function$
","null"
"FUNCTION","storage","get_size_by_bucket","null","CREATE OR REPLACE FUNCTION storage.get_size_by_bucket()
 RETURNS TABLE(size bigint, bucket_id text)
 LANGUAGE plpgsql
AS $function$
BEGIN
    return query
        select sum((metadata->>'size')::int) as size, obj.bucket_id
        from "storage".objects as obj
        group by obj.bucket_id;
END
$function$
","null"
"FUNCTION","storage","list_multipart_uploads_with_delimiter","null","CREATE OR REPLACE FUNCTION storage.list_multipart_uploads_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, next_key_token text DEFAULT ''::text, next_upload_token text DEFAULT ''::text)
 RETURNS TABLE(key text, id text, created_at timestamp with time zone)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY EXECUTE
        'SELECT DISTINCT ON(key COLLATE "C") * from (
            SELECT
                CASE
                    WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN
                        substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1)))
                    ELSE
                        key
                END AS key, id, created_at
            FROM
                storage.s3_multipart_uploads
            WHERE
                bucket_id = $5 AND
                key ILIKE $1 || ''%'' AND
                CASE
                    WHEN $4 != '''' AND $6 = '''' THEN
                        CASE
                            WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN
                                substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1))) COLLATE "C" > $4
                            ELSE
                                key COLLATE "C" > $4
                            END
                    ELSE
                        true
                END AND
                CASE
                    WHEN $6 != '''' THEN
                        id COLLATE "C" > $6
                    ELSE
                        true
                    END
            ORDER BY
                key COLLATE "C" ASC, created_at ASC) as e order by key COLLATE "C" LIMIT $3'
        USING prefix_param, delimiter_param, max_keys, next_key_token, bucket_id, next_upload_token;
END;
$function$
","null"
"FUNCTION","storage","list_objects_with_delimiter","null","CREATE OR REPLACE FUNCTION storage.list_objects_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, start_after text DEFAULT ''::text, next_token text DEFAULT ''::text)
 RETURNS TABLE(name text, id uuid, metadata jsonb, updated_at timestamp with time zone)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY EXECUTE
        'SELECT DISTINCT ON(name COLLATE "C") * from (
            SELECT
                CASE
                    WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN
                        substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1)))
                    ELSE
                        name
                END AS name, id, metadata, updated_at
            FROM
                storage.objects
            WHERE
                bucket_id = $5 AND
                name ILIKE $1 || ''%'' AND
                CASE
                    WHEN $6 != '''' THEN
                    name COLLATE "C" > $6
                ELSE true END
                AND CASE
                    WHEN $4 != '''' THEN
                        CASE
                            WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN
                                substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1))) COLLATE "C" > $4
                            ELSE
                                name COLLATE "C" > $4
                            END
                    ELSE
                        true
                END
            ORDER BY
                name COLLATE "C" ASC) as e order by name COLLATE "C" LIMIT $3'
        USING prefix_param, delimiter_param, max_keys, next_token, bucket_id, start_after;
END;
$function$
","null"
"FUNCTION","storage","operation","null","CREATE OR REPLACE FUNCTION storage.operation()
 RETURNS text
 LANGUAGE plpgsql
 STABLE
AS $function$
BEGIN
    RETURN current_setting('storage.operation', true);
END;
$function$
","null"
"FUNCTION","storage","search","null","CREATE OR REPLACE FUNCTION storage.search(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)
 RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)
 LANGUAGE plpgsql
 STABLE
AS $function$
declare
  v_order_by text;
  v_sort_order text;
begin
  case
    when sortcolumn = 'name' then
      v_order_by = 'name';
    when sortcolumn = 'updated_at' then
      v_order_by = 'updated_at';
    when sortcolumn = 'created_at' then
      v_order_by = 'created_at';
    when sortcolumn = 'last_accessed_at' then
      v_order_by = 'last_accessed_at';
    else
      v_order_by = 'name';
  end case;

  case
    when sortorder = 'asc' then
      v_sort_order = 'asc';
    when sortorder = 'desc' then
      v_sort_order = 'desc';
    else
      v_sort_order = 'asc';
  end case;

  v_order_by = v_order_by || ' ' || v_sort_order;

  return query execute
    'with folders as (
       select path_tokens[$1] as folder
       from storage.objects
         where objects.name ilike $2 || $3 || ''%''
           and bucket_id = $4
           and array_length(objects.path_tokens, 1) <> $1
       group by folder
       order by folder ' || v_sort_order || '
     )
     (select folder as "name",
            null as id,
            null as updated_at,
            null as created_at,
            null as last_accessed_at,
            null as metadata from folders)
     union all
     (select path_tokens[$1] as "name",
            id,
            updated_at,
            created_at,
            last_accessed_at,
            metadata
     from storage.objects
     where objects.name ilike $2 || $3 || ''%''
       and bucket_id = $4
       and array_length(objects.path_tokens, 1) = $1
     order by ' || v_order_by || ')
     limit $5
     offset $6' using levels, prefix, search, bucketname, limits, offsets;
end;
$function$
","null"
"FUNCTION","storage","update_updated_at_column","null","CREATE OR REPLACE FUNCTION storage.update_updated_at_column()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = now();
    RETURN NEW; 
END;
$function$
","null"
"FUNCTION","vault","create_secret","null","CREATE OR REPLACE FUNCTION vault.create_secret(new_secret text, new_name text DEFAULT NULL::text, new_description text DEFAULT ''::text, new_key_id uuid DEFAULT NULL::uuid)
 RETURNS uuid
 LANGUAGE sql
AS $function$
    INSERT INTO vault.secrets (secret, name, description, key_id)
    VALUES (
        new_secret,
        new_name,
        new_description,
        CASE WHEN new_key_id IS NULL THEN (pgsodium.create_key()).id ELSE new_key_id END)
    RETURNING id;
    $function$
","null"
"FUNCTION","vault","secrets_encrypt_secret_secret","null","CREATE OR REPLACE FUNCTION vault.secrets_encrypt_secret_secret()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
		BEGIN
		        new.secret = CASE WHEN new.secret IS NULL THEN NULL ELSE
			CASE WHEN new.key_id IS NULL THEN NULL ELSE pg_catalog.encode(
			  pgsodium.crypto_aead_det_encrypt(
				pg_catalog.convert_to(new.secret, 'utf8'),
				pg_catalog.convert_to((new.id::text || new.description::text || new.created_at::text || new.updated_at::text)::text, 'utf8'),
				new.key_id::uuid,
				new.nonce
			  ),
				'base64') END END;
		RETURN new;
		END;
		$function$
","null"
"FUNCTION","vault","update_secret","null","CREATE OR REPLACE FUNCTION vault.update_secret(secret_id uuid, new_secret text DEFAULT NULL::text, new_name text DEFAULT NULL::text, new_description text DEFAULT NULL::text, new_key_id uuid DEFAULT NULL::uuid)
 RETURNS void
 LANGUAGE sql
AS $function$
	UPDATE vault.decrypted_secrets s
    SET
        secret = CASE WHEN new_secret IS NULL THEN s.decrypted_secret ELSE new_secret END,
        name = CASE WHEN new_name IS NULL THEN s.name ELSE new_name END,
        description = CASE WHEN new_description IS NULL THEN s.description ELSE new_description END,
        key_id = CASE WHEN new_key_id IS NULL THEN s.key_id ELSE new_key_id END,
        updated_at = CURRENT_TIMESTAMP
    WHERE s.id = secret_id
    $function$
","null"
"INDEX","auth","audit_log_entries","audit_log_entries_pkey","CREATE UNIQUE INDEX audit_log_entries_pkey ON auth.audit_log_entries USING btree (id)","null"
"INDEX","auth","audit_log_entries","audit_logs_instance_id_idx","CREATE INDEX audit_logs_instance_id_idx ON auth.audit_log_entries USING btree (instance_id)","null"
"INDEX","auth","flow_state","flow_state_created_at_idx","CREATE INDEX flow_state_created_at_idx ON auth.flow_state USING btree (created_at DESC)","null"
"INDEX","auth","flow_state","flow_state_pkey","CREATE UNIQUE INDEX flow_state_pkey ON auth.flow_state USING btree (id)","null"
"INDEX","auth","flow_state","idx_auth_code","CREATE INDEX idx_auth_code ON auth.flow_state USING btree (auth_code)","null"
"INDEX","auth","flow_state","idx_user_id_auth_method","CREATE INDEX idx_user_id_auth_method ON auth.flow_state USING btree (user_id, authentication_method)","null"
"INDEX","auth","identities","identities_email_idx","CREATE INDEX identities_email_idx ON auth.identities USING btree (email text_pattern_ops)","null"
"INDEX","auth","identities","identities_pkey","CREATE UNIQUE INDEX identities_pkey ON auth.identities USING btree (id)","null"
"INDEX","auth","identities","identities_provider_id_provider_unique","CREATE UNIQUE INDEX identities_provider_id_provider_unique ON auth.identities USING btree (provider_id, provider)","null"
"INDEX","auth","identities","identities_user_id_idx","CREATE INDEX identities_user_id_idx ON auth.identities USING btree (user_id)","null"
"INDEX","auth","instances","instances_pkey","CREATE UNIQUE INDEX instances_pkey ON auth.instances USING btree (id)","null"
"INDEX","auth","mfa_amr_claims","amr_id_pk","CREATE UNIQUE INDEX amr_id_pk ON auth.mfa_amr_claims USING btree (id)","null"
"INDEX","auth","mfa_amr_claims","mfa_amr_claims_session_id_authentication_method_pkey","CREATE UNIQUE INDEX mfa_amr_claims_session_id_authentication_method_pkey ON auth.mfa_amr_claims USING btree (session_id, authentication_method)","null"
"INDEX","auth","mfa_challenges","mfa_challenge_created_at_idx","CREATE INDEX mfa_challenge_created_at_idx ON auth.mfa_challenges USING btree (created_at DESC)","null"
"INDEX","auth","mfa_challenges","mfa_challenges_pkey","CREATE UNIQUE INDEX mfa_challenges_pkey ON auth.mfa_challenges USING btree (id)","null"
"INDEX","auth","mfa_factors","factor_id_created_at_idx","CREATE INDEX factor_id_created_at_idx ON auth.mfa_factors USING btree (user_id, created_at)","null"
"INDEX","auth","mfa_factors","mfa_factors_last_challenged_at_key","CREATE UNIQUE INDEX mfa_factors_last_challenged_at_key ON auth.mfa_factors USING btree (last_challenged_at)","null"
"INDEX","auth","mfa_factors","mfa_factors_pkey","CREATE UNIQUE INDEX mfa_factors_pkey ON auth.mfa_factors USING btree (id)","null"
"INDEX","auth","mfa_factors","mfa_factors_user_friendly_name_unique","CREATE UNIQUE INDEX mfa_factors_user_friendly_name_unique ON auth.mfa_factors USING btree (friendly_name, user_id) WHERE (TRIM(BOTH FROM friendly_name) <> ''::text)","null"
"INDEX","auth","mfa_factors","mfa_factors_user_id_idx","CREATE INDEX mfa_factors_user_id_idx ON auth.mfa_factors USING btree (user_id)","null"
"INDEX","auth","mfa_factors","unique_phone_factor_per_user","CREATE UNIQUE INDEX unique_phone_factor_per_user ON auth.mfa_factors USING btree (user_id, phone)","null"
"INDEX","auth","one_time_tokens","one_time_tokens_pkey","CREATE UNIQUE INDEX one_time_tokens_pkey ON auth.one_time_tokens USING btree (id)","null"
"INDEX","auth","one_time_tokens","one_time_tokens_relates_to_hash_idx","CREATE INDEX one_time_tokens_relates_to_hash_idx ON auth.one_time_tokens USING hash (relates_to)","null"
"INDEX","auth","one_time_tokens","one_time_tokens_token_hash_hash_idx","CREATE INDEX one_time_tokens_token_hash_hash_idx ON auth.one_time_tokens USING hash (token_hash)","null"
"INDEX","auth","one_time_tokens","one_time_tokens_user_id_token_type_key","CREATE UNIQUE INDEX one_time_tokens_user_id_token_type_key ON auth.one_time_tokens USING btree (user_id, token_type)","null"
"INDEX","auth","refresh_tokens","refresh_tokens_instance_id_idx","CREATE INDEX refresh_tokens_instance_id_idx ON auth.refresh_tokens USING btree (instance_id)","null"
"INDEX","auth","refresh_tokens","refresh_tokens_instance_id_user_id_idx","CREATE INDEX refresh_tokens_instance_id_user_id_idx ON auth.refresh_tokens USING btree (instance_id, user_id)","null"
"INDEX","auth","refresh_tokens","refresh_tokens_parent_idx","CREATE INDEX refresh_tokens_parent_idx ON auth.refresh_tokens USING btree (parent)","null"
"INDEX","auth","refresh_tokens","refresh_tokens_pkey","CREATE UNIQUE INDEX refresh_tokens_pkey ON auth.refresh_tokens USING btree (id)","null"
"INDEX","auth","refresh_tokens","refresh_tokens_session_id_revoked_idx","CREATE INDEX refresh_tokens_session_id_revoked_idx ON auth.refresh_tokens USING btree (session_id, revoked)","null"
"INDEX","auth","refresh_tokens","refresh_tokens_token_unique","CREATE UNIQUE INDEX refresh_tokens_token_unique ON auth.refresh_tokens USING btree (token)","null"
"INDEX","auth","refresh_tokens","refresh_tokens_updated_at_idx","CREATE INDEX refresh_tokens_updated_at_idx ON auth.refresh_tokens USING btree (updated_at DESC)","null"
"INDEX","auth","saml_providers","saml_providers_entity_id_key","CREATE UNIQUE INDEX saml_providers_entity_id_key ON auth.saml_providers USING btree (entity_id)","null"
"INDEX","auth","saml_providers","saml_providers_pkey","CREATE UNIQUE INDEX saml_providers_pkey ON auth.saml_providers USING btree (id)","null"
"INDEX","auth","saml_providers","saml_providers_sso_provider_id_idx","CREATE INDEX saml_providers_sso_provider_id_idx ON auth.saml_providers USING btree (sso_provider_id)","null"
"INDEX","auth","saml_relay_states","saml_relay_states_created_at_idx","CREATE INDEX saml_relay_states_created_at_idx ON auth.saml_relay_states USING btree (created_at DESC)","null"
"INDEX","auth","saml_relay_states","saml_relay_states_for_email_idx","CREATE INDEX saml_relay_states_for_email_idx ON auth.saml_relay_states USING btree (for_email)","null"
"INDEX","auth","saml_relay_states","saml_relay_states_pkey","CREATE UNIQUE INDEX saml_relay_states_pkey ON auth.saml_relay_states USING btree (id)","null"
"INDEX","auth","saml_relay_states","saml_relay_states_sso_provider_id_idx","CREATE INDEX saml_relay_states_sso_provider_id_idx ON auth.saml_relay_states USING btree (sso_provider_id)","null"
"INDEX","auth","schema_migrations","schema_migrations_pkey","CREATE UNIQUE INDEX schema_migrations_pkey ON auth.schema_migrations USING btree (version)","null"
"INDEX","auth","sessions","sessions_not_after_idx","CREATE INDEX sessions_not_after_idx ON auth.sessions USING btree (not_after DESC)","null"
"INDEX","auth","sessions","sessions_pkey","CREATE UNIQUE INDEX sessions_pkey ON auth.sessions USING btree (id)","null"
"INDEX","auth","sessions","sessions_user_id_idx","CREATE INDEX sessions_user_id_idx ON auth.sessions USING btree (user_id)","null"
"INDEX","auth","sessions","user_id_created_at_idx","CREATE INDEX user_id_created_at_idx ON auth.sessions USING btree (user_id, created_at)","null"
"INDEX","auth","sso_domains","sso_domains_domain_idx","CREATE UNIQUE INDEX sso_domains_domain_idx ON auth.sso_domains USING btree (lower(domain))","null"
"INDEX","auth","sso_domains","sso_domains_pkey","CREATE UNIQUE INDEX sso_domains_pkey ON auth.sso_domains USING btree (id)","null"
"INDEX","auth","sso_domains","sso_domains_sso_provider_id_idx","CREATE INDEX sso_domains_sso_provider_id_idx ON auth.sso_domains USING btree (sso_provider_id)","null"
"INDEX","auth","sso_providers","sso_providers_pkey","CREATE UNIQUE INDEX sso_providers_pkey ON auth.sso_providers USING btree (id)","null"
"INDEX","auth","sso_providers","sso_providers_resource_id_idx","CREATE UNIQUE INDEX sso_providers_resource_id_idx ON auth.sso_providers USING btree (lower(resource_id))","null"
"INDEX","auth","users","confirmation_token_idx","CREATE UNIQUE INDEX confirmation_token_idx ON auth.users USING btree (confirmation_token) WHERE ((confirmation_token)::text !~ '^[0-9 ]*$'::text)","null"
"INDEX","auth","users","email_change_token_current_idx","CREATE UNIQUE INDEX email_change_token_current_idx ON auth.users USING btree (email_change_token_current) WHERE ((email_change_token_current)::text !~ '^[0-9 ]*$'::text)","null"
"INDEX","auth","users","email_change_token_new_idx","CREATE UNIQUE INDEX email_change_token_new_idx ON auth.users USING btree (email_change_token_new) WHERE ((email_change_token_new)::text !~ '^[0-9 ]*$'::text)","null"
"INDEX","auth","users","reauthentication_token_idx","CREATE UNIQUE INDEX reauthentication_token_idx ON auth.users USING btree (reauthentication_token) WHERE ((reauthentication_token)::text !~ '^[0-9 ]*$'::text)","null"
"INDEX","auth","users","recovery_token_idx","CREATE UNIQUE INDEX recovery_token_idx ON auth.users USING btree (recovery_token) WHERE ((recovery_token)::text !~ '^[0-9 ]*$'::text)","null"
"INDEX","auth","users","users_email_partial_key","CREATE UNIQUE INDEX users_email_partial_key ON auth.users USING btree (email) WHERE (is_sso_user = false)","null"
"INDEX","auth","users","users_instance_id_email_idx","CREATE INDEX users_instance_id_email_idx ON auth.users USING btree (instance_id, lower((email)::text))","null"
"INDEX","auth","users","users_instance_id_idx","CREATE INDEX users_instance_id_idx ON auth.users USING btree (instance_id)","null"
"INDEX","auth","users","users_is_anonymous_idx","CREATE INDEX users_is_anonymous_idx ON auth.users USING btree (is_anonymous)","null"
"INDEX","auth","users","users_phone_key","CREATE UNIQUE INDEX users_phone_key ON auth.users USING btree (phone)","null"
"INDEX","auth","users","users_pkey","CREATE UNIQUE INDEX users_pkey ON auth.users USING btree (id)","null"
"INDEX","pg_toast","pg_toast_1213","pg_toast_1213_index","CREATE UNIQUE INDEX pg_toast_1213_index ON pg_toast.pg_toast_1213 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_1247","pg_toast_1247_index","CREATE UNIQUE INDEX pg_toast_1247_index ON pg_toast.pg_toast_1247 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_1255","pg_toast_1255_index","CREATE UNIQUE INDEX pg_toast_1255_index ON pg_toast.pg_toast_1255 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_1260","pg_toast_1260_index","CREATE UNIQUE INDEX pg_toast_1260_index ON pg_toast.pg_toast_1260 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_1262","pg_toast_1262_index","CREATE UNIQUE INDEX pg_toast_1262_index ON pg_toast.pg_toast_1262 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_13392","pg_toast_13392_index","CREATE UNIQUE INDEX pg_toast_13392_index ON pg_toast.pg_toast_13392 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_13397","pg_toast_13397_index","CREATE UNIQUE INDEX pg_toast_13397_index ON pg_toast.pg_toast_13397 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_13402","pg_toast_13402_index","CREATE UNIQUE INDEX pg_toast_13402_index ON pg_toast.pg_toast_13402 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_13407","pg_toast_13407_index","CREATE UNIQUE INDEX pg_toast_13407_index ON pg_toast.pg_toast_13407 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_1417","pg_toast_1417_index","CREATE UNIQUE INDEX pg_toast_1417_index ON pg_toast.pg_toast_1417 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_1418","pg_toast_1418_index","CREATE UNIQUE INDEX pg_toast_1418_index ON pg_toast.pg_toast_1418 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_16489","pg_toast_16489_index","CREATE UNIQUE INDEX pg_toast_16489_index ON pg_toast.pg_toast_16489 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_16501","pg_toast_16501_index","CREATE UNIQUE INDEX pg_toast_16501_index ON pg_toast.pg_toast_16501 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_16512","pg_toast_16512_index","CREATE UNIQUE INDEX pg_toast_16512_index ON pg_toast.pg_toast_16512 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_16519","pg_toast_16519_index","CREATE UNIQUE INDEX pg_toast_16519_index ON pg_toast.pg_toast_16519 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_16540","pg_toast_16540_index","CREATE UNIQUE INDEX pg_toast_16540_index ON pg_toast.pg_toast_16540 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_16555","pg_toast_16555_index","CREATE UNIQUE INDEX pg_toast_16555_index ON pg_toast.pg_toast_16555 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_16790","pg_toast_16790_index","CREATE UNIQUE INDEX pg_toast_16790_index ON pg_toast.pg_toast_16790 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_16951","pg_toast_16951_index","CREATE UNIQUE INDEX pg_toast_16951_index ON pg_toast.pg_toast_16951 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_2328","pg_toast_2328_index","CREATE UNIQUE INDEX pg_toast_2328_index ON pg_toast.pg_toast_2328 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_2396","pg_toast_2396_index","CREATE UNIQUE INDEX pg_toast_2396_index ON pg_toast.pg_toast_2396 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_2600","pg_toast_2600_index","CREATE UNIQUE INDEX pg_toast_2600_index ON pg_toast.pg_toast_2600 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_2604","pg_toast_2604_index","CREATE UNIQUE INDEX pg_toast_2604_index ON pg_toast.pg_toast_2604 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_2606","pg_toast_2606_index","CREATE UNIQUE INDEX pg_toast_2606_index ON pg_toast.pg_toast_2606 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_2609","pg_toast_2609_index","CREATE UNIQUE INDEX pg_toast_2609_index ON pg_toast.pg_toast_2609 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_2612","pg_toast_2612_index","CREATE UNIQUE INDEX pg_toast_2612_index ON pg_toast.pg_toast_2612 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_2615","pg_toast_2615_index","CREATE UNIQUE INDEX pg_toast_2615_index ON pg_toast.pg_toast_2615 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_2618","pg_toast_2618_index","CREATE UNIQUE INDEX pg_toast_2618_index ON pg_toast.pg_toast_2618 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_2619","pg_toast_2619_index","CREATE UNIQUE INDEX pg_toast_2619_index ON pg_toast.pg_toast_2619 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_2620","pg_toast_2620_index","CREATE UNIQUE INDEX pg_toast_2620_index ON pg_toast.pg_toast_2620 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_28728","pg_toast_28728_index","CREATE UNIQUE INDEX pg_toast_28728_index ON pg_toast.pg_toast_28728 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_28758","pg_toast_28758_index","CREATE UNIQUE INDEX pg_toast_28758_index ON pg_toast.pg_toast_28758 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_28793","pg_toast_28793_index","CREATE UNIQUE INDEX pg_toast_28793_index ON pg_toast.pg_toast_28793 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_28806","pg_toast_28806_index","CREATE UNIQUE INDEX pg_toast_28806_index ON pg_toast.pg_toast_28806 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_28818","pg_toast_28818_index","CREATE UNIQUE INDEX pg_toast_28818_index ON pg_toast.pg_toast_28818 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_28836","pg_toast_28836_index","CREATE UNIQUE INDEX pg_toast_28836_index ON pg_toast.pg_toast_28836 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_28845","pg_toast_28845_index","CREATE UNIQUE INDEX pg_toast_28845_index ON pg_toast.pg_toast_28845 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_28860","pg_toast_28860_index","CREATE UNIQUE INDEX pg_toast_28860_index ON pg_toast.pg_toast_28860 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_28878","pg_toast_28878_index","CREATE UNIQUE INDEX pg_toast_28878_index ON pg_toast.pg_toast_28878 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_28931","pg_toast_28931_index","CREATE UNIQUE INDEX pg_toast_28931_index ON pg_toast.pg_toast_28931 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_28981","pg_toast_28981_index","CREATE UNIQUE INDEX pg_toast_28981_index ON pg_toast.pg_toast_28981 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_29038","pg_toast_29038_index","CREATE UNIQUE INDEX pg_toast_29038_index ON pg_toast.pg_toast_29038 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_29052","pg_toast_29052_index","CREATE UNIQUE INDEX pg_toast_29052_index ON pg_toast.pg_toast_29052 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_29117","pg_toast_29117_index","CREATE UNIQUE INDEX pg_toast_29117_index ON pg_toast.pg_toast_29117 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_29627","pg_toast_29627_index","CREATE UNIQUE INDEX pg_toast_29627_index ON pg_toast.pg_toast_29627 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_2964","pg_toast_2964_index","CREATE UNIQUE INDEX pg_toast_2964_index ON pg_toast.pg_toast_2964 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_29643","pg_toast_29643_index","CREATE UNIQUE INDEX pg_toast_29643_index ON pg_toast.pg_toast_29643 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_29674","pg_toast_29674_index","CREATE UNIQUE INDEX pg_toast_29674_index ON pg_toast.pg_toast_29674 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_29723","pg_toast_29723_index","CREATE UNIQUE INDEX pg_toast_29723_index ON pg_toast.pg_toast_29723 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_29743","pg_toast_29743_index","CREATE UNIQUE INDEX pg_toast_29743_index ON pg_toast.pg_toast_29743 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_29764","pg_toast_29764_index","CREATE UNIQUE INDEX pg_toast_29764_index ON pg_toast.pg_toast_29764 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_29836","pg_toast_29836_index","CREATE UNIQUE INDEX pg_toast_29836_index ON pg_toast.pg_toast_29836 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_3079","pg_toast_3079_index","CREATE UNIQUE INDEX pg_toast_3079_index ON pg_toast.pg_toast_3079 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_3118","pg_toast_3118_index","CREATE UNIQUE INDEX pg_toast_3118_index ON pg_toast.pg_toast_3118 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_3256","pg_toast_3256_index","CREATE UNIQUE INDEX pg_toast_3256_index ON pg_toast.pg_toast_3256 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_3350","pg_toast_3350_index","CREATE UNIQUE INDEX pg_toast_3350_index ON pg_toast.pg_toast_3350 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_3381","pg_toast_3381_index","CREATE UNIQUE INDEX pg_toast_3381_index ON pg_toast.pg_toast_3381 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_3394","pg_toast_3394_index","CREATE UNIQUE INDEX pg_toast_3394_index ON pg_toast.pg_toast_3394 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_3429","pg_toast_3429_index","CREATE UNIQUE INDEX pg_toast_3429_index ON pg_toast.pg_toast_3429 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_3456","pg_toast_3456_index","CREATE UNIQUE INDEX pg_toast_3456_index ON pg_toast.pg_toast_3456 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_3466","pg_toast_3466_index","CREATE UNIQUE INDEX pg_toast_3466_index ON pg_toast.pg_toast_3466 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_3592","pg_toast_3592_index","CREATE UNIQUE INDEX pg_toast_3592_index ON pg_toast.pg_toast_3592 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_3596","pg_toast_3596_index","CREATE UNIQUE INDEX pg_toast_3596_index ON pg_toast.pg_toast_3596 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_3600","pg_toast_3600_index","CREATE UNIQUE INDEX pg_toast_3600_index ON pg_toast.pg_toast_3600 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_6000","pg_toast_6000_index","CREATE UNIQUE INDEX pg_toast_6000_index ON pg_toast.pg_toast_6000 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_6100","pg_toast_6100_index","CREATE UNIQUE INDEX pg_toast_6100_index ON pg_toast.pg_toast_6100 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_6106","pg_toast_6106_index","CREATE UNIQUE INDEX pg_toast_6106_index ON pg_toast.pg_toast_6106 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_6243","pg_toast_6243_index","CREATE UNIQUE INDEX pg_toast_6243_index ON pg_toast.pg_toast_6243 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pg_toast","pg_toast_826","pg_toast_826_index","CREATE UNIQUE INDEX pg_toast_826_index ON pg_toast.pg_toast_826 USING btree (chunk_id, chunk_seq)","null"
"INDEX","pgsodium","key","key_key_id_key_context_key_type_idx","CREATE UNIQUE INDEX key_key_id_key_context_key_type_idx ON pgsodium.key USING btree (key_id, key_context, key_type)","null"
"INDEX","pgsodium","key","key_pkey","CREATE UNIQUE INDEX key_pkey ON pgsodium.key USING btree (id)","null"
"INDEX","pgsodium","key","key_status_idx","CREATE INDEX key_status_idx ON pgsodium.key USING btree (status) WHERE (status = ANY (ARRAY['valid'::pgsodium.key_status, 'default'::pgsodium.key_status]))","null"
"INDEX","pgsodium","key","key_status_idx1","CREATE UNIQUE INDEX key_status_idx1 ON pgsodium.key USING btree (status) WHERE (status = 'default'::pgsodium.key_status)","null"
"INDEX","pgsodium","key","pgsodium_key_unique_name","CREATE UNIQUE INDEX pgsodium_key_unique_name ON pgsodium.key USING btree (name)","null"
"INDEX","public","comment_votes","comment_votes_comment_id_idx","CREATE INDEX comment_votes_comment_id_idx ON public.comment_votes USING btree (comment_id)","null"
"INDEX","public","comment_votes","comment_votes_pkey","CREATE UNIQUE INDEX comment_votes_pkey ON public.comment_votes USING btree (id)","null"
"INDEX","public","comment_votes","comment_votes_user_comment_unique","CREATE UNIQUE INDEX comment_votes_user_comment_unique ON public.comment_votes USING btree (user_id, comment_id)","null"
"INDEX","public","comment_votes","comment_votes_user_id_idx","CREATE INDEX comment_votes_user_id_idx ON public.comment_votes USING btree (user_id)","null"
"INDEX","public","comments","comments_pkey","CREATE UNIQUE INDEX comments_pkey ON public.comments USING btree (id)","null"
"INDEX","public","comments","idx_comments_post_id","CREATE INDEX idx_comments_post_id ON public.comments USING btree (post_id)","null"
"INDEX","public","comments","idx_comments_user_id","CREATE INDEX idx_comments_user_id ON public.comments USING btree (user_id)","null"
"INDEX","public","conversation_participants","conversation_participants_conversation_id_user_id_key","CREATE UNIQUE INDEX conversation_participants_conversation_id_user_id_key ON public.conversation_participants USING btree (conversation_id, user_id)","null"
"INDEX","public","conversation_participants","conversation_participants_pkey","CREATE UNIQUE INDEX conversation_participants_pkey ON public.conversation_participants USING btree (id)","null"
"INDEX","public","conversation_participants","idx_conversation_participants_conversation_id","CREATE INDEX idx_conversation_participants_conversation_id ON public.conversation_participants USING btree (conversation_id)","null"
"INDEX","public","conversation_participants","idx_conversation_participants_user_id","CREATE INDEX idx_conversation_participants_user_id ON public.conversation_participants USING btree (user_id)","null"
"INDEX","public","conversations","conversations_pkey","CREATE UNIQUE INDEX conversations_pkey ON public.conversations USING btree (id)","null"
"INDEX","public","friendships","friendships_pkey","CREATE UNIQUE INDEX friendships_pkey ON public.friendships USING btree (id)","null"
"INDEX","public","friendships","friendships_user_id_friend_id_key","CREATE UNIQUE INDEX friendships_user_id_friend_id_key ON public.friendships USING btree (user_id, friend_id)","null"
"INDEX","public","friendships","idx_friendships_friend_id","CREATE INDEX idx_friendships_friend_id ON public.friendships USING btree (friend_id)","null"
"INDEX","public","friendships","idx_friendships_user_id","CREATE INDEX idx_friendships_user_id ON public.friendships USING btree (user_id)","null"
"INDEX","public","group_members","group_members_group_id_user_id_key","CREATE UNIQUE INDEX group_members_group_id_user_id_key ON public.group_members USING btree (group_id, user_id)","null"
"INDEX","public","group_members","group_members_pkey","CREATE UNIQUE INDEX group_members_pkey ON public.group_members USING btree (id)","null"
"INDEX","public","group_members","idx_group_members_group_id","CREATE INDEX idx_group_members_group_id ON public.group_members USING btree (group_id)","null"
"INDEX","public","group_members","idx_group_members_user_id","CREATE INDEX idx_group_members_user_id ON public.group_members USING btree (user_id)","null"
"INDEX","public","groups","groups_pkey","CREATE UNIQUE INDEX groups_pkey ON public.groups USING btree (id)","null"
"INDEX","public","likes","idx_likes_comment_id","CREATE INDEX idx_likes_comment_id ON public.likes USING btree (comment_id)","null"
"INDEX","public","likes","idx_likes_post_id","CREATE INDEX idx_likes_post_id ON public.likes USING btree (post_id)","null"
"INDEX","public","likes","idx_likes_user_id","CREATE INDEX idx_likes_user_id ON public.likes USING btree (user_id)","null"
"INDEX","public","likes","likes_pkey","CREATE UNIQUE INDEX likes_pkey ON public.likes USING btree (id)","null"
"INDEX","public","likes","likes_user_id_post_id_comment_id_key","CREATE UNIQUE INDEX likes_user_id_post_id_comment_id_key ON public.likes USING btree (user_id, post_id, comment_id)","null"
"INDEX","public","media","idx_media_message_id","CREATE INDEX idx_media_message_id ON public.media USING btree (message_id)","null"
"INDEX","public","media","idx_media_post_id","CREATE INDEX idx_media_post_id ON public.media USING btree (post_id)","null"
"INDEX","public","media","media_pkey","CREATE UNIQUE INDEX media_pkey ON public.media USING btree (id)","null"
"INDEX","public","messages","idx_messages_conversation_id","CREATE INDEX idx_messages_conversation_id ON public.messages USING btree (conversation_id)","null"
"INDEX","public","messages","messages_pkey","CREATE UNIQUE INDEX messages_pkey ON public.messages USING btree (id)","null"
"INDEX","public","notifications","idx_notifications_user_id","CREATE INDEX idx_notifications_user_id ON public.notifications USING btree (user_id)","null"
"INDEX","public","notifications","notifications_pkey","CREATE UNIQUE INDEX notifications_pkey ON public.notifications USING btree (id)","null"
"INDEX","public","posts","idx_posts_group_id","CREATE INDEX idx_posts_group_id ON public.posts USING btree (group_id)","null"
"INDEX","public","posts","idx_posts_user_id","CREATE INDEX idx_posts_user_id ON public.posts USING btree (user_id)","null"
"INDEX","public","posts","posts_pkey","CREATE UNIQUE INDEX posts_pkey ON public.posts USING btree (id)","null"
"INDEX","public","posts","posts_search_idx","CREATE INDEX posts_search_idx ON public.posts USING gin (search_vector)","null"
"INDEX","public","user_hidden_posts","idx_user_hidden_posts_hidden_at","CREATE INDEX idx_user_hidden_posts_hidden_at ON public.user_hidden_posts USING btree (hidden_at)","null"
"INDEX","public","user_hidden_posts","idx_user_hidden_posts_post_id","CREATE INDEX idx_user_hidden_posts_post_id ON public.user_hidden_posts USING btree (post_id)","null"
"INDEX","public","user_hidden_posts","idx_user_hidden_posts_user_id","CREATE INDEX idx_user_hidden_posts_user_id ON public.user_hidden_posts USING btree (user_id)","null"
"INDEX","public","user_hidden_posts","user_hidden_posts_pkey","CREATE UNIQUE INDEX user_hidden_posts_pkey ON public.user_hidden_posts USING btree (user_id, post_id)","null"
"INDEX","public","user_saved_posts","idx_user_saved_posts_post_id","CREATE INDEX idx_user_saved_posts_post_id ON public.user_saved_posts USING btree (post_id)","null"
"INDEX","public","user_saved_posts","idx_user_saved_posts_saved_at","CREATE INDEX idx_user_saved_posts_saved_at ON public.user_saved_posts USING btree (saved_at)","null"
"INDEX","public","user_saved_posts","idx_user_saved_posts_user_id","CREATE INDEX idx_user_saved_posts_user_id ON public.user_saved_posts USING btree (user_id)","null"
"INDEX","public","user_saved_posts","user_saved_posts_pkey","CREATE UNIQUE INDEX user_saved_posts_pkey ON public.user_saved_posts USING btree (user_id, post_id)","null"
"INDEX","public","users","idx_users_username","CREATE INDEX idx_users_username ON public.users USING btree (username)","null"
"INDEX","public","users","users_email_key","CREATE UNIQUE INDEX users_email_key ON public.users USING btree (email)","null"
"INDEX","public","users","users_pkey","CREATE UNIQUE INDEX users_pkey ON public.users USING btree (id)","null"
"INDEX","public","users","users_username_key","CREATE UNIQUE INDEX users_username_key ON public.users USING btree (username)","null"
"INDEX","realtime","messages","messages_pkey","CREATE UNIQUE INDEX messages_pkey ON ONLY realtime.messages USING btree (id, inserted_at)","null"
"INDEX","realtime","schema_migrations","schema_migrations_pkey","CREATE UNIQUE INDEX schema_migrations_pkey ON realtime.schema_migrations USING btree (version)","null"
"INDEX","realtime","subscription","ix_realtime_subscription_entity","CREATE INDEX ix_realtime_subscription_entity ON realtime.subscription USING btree (entity)","null"
"INDEX","realtime","subscription","pk_subscription","CREATE UNIQUE INDEX pk_subscription ON realtime.subscription USING btree (id)","null"
"INDEX","realtime","subscription","subscription_subscription_id_entity_filters_key","CREATE UNIQUE INDEX subscription_subscription_id_entity_filters_key ON realtime.subscription USING btree (subscription_id, entity, filters)","null"
"INDEX","storage","buckets","bname","CREATE UNIQUE INDEX bname ON storage.buckets USING btree (name)","null"
"INDEX","storage","buckets","buckets_pkey","CREATE UNIQUE INDEX buckets_pkey ON storage.buckets USING btree (id)","null"
"INDEX","storage","migrations","migrations_name_key","CREATE UNIQUE INDEX migrations_name_key ON storage.migrations USING btree (name)","null"
"INDEX","storage","migrations","migrations_pkey","CREATE UNIQUE INDEX migrations_pkey ON storage.migrations USING btree (id)","null"
"INDEX","storage","objects","bucketid_objname","CREATE UNIQUE INDEX bucketid_objname ON storage.objects USING btree (bucket_id, name)","null"
"INDEX","storage","objects","idx_objects_bucket_id_name","CREATE INDEX idx_objects_bucket_id_name ON storage.objects USING btree (bucket_id, name COLLATE "C")","null"
"INDEX","storage","objects","name_prefix_search","CREATE INDEX name_prefix_search ON storage.objects USING btree (name text_pattern_ops)","null"
"INDEX","storage","objects","objects_pkey","CREATE UNIQUE INDEX objects_pkey ON storage.objects USING btree (id)","null"
"INDEX","storage","s3_multipart_uploads","idx_multipart_uploads_list","CREATE INDEX idx_multipart_uploads_list ON storage.s3_multipart_uploads USING btree (bucket_id, key, created_at)","null"
"INDEX","storage","s3_multipart_uploads","s3_multipart_uploads_pkey","CREATE UNIQUE INDEX s3_multipart_uploads_pkey ON storage.s3_multipart_uploads USING btree (id)","null"
"INDEX","storage","s3_multipart_uploads_parts","s3_multipart_uploads_parts_pkey","CREATE UNIQUE INDEX s3_multipart_uploads_parts_pkey ON storage.s3_multipart_uploads_parts USING btree (id)","null"
"INDEX","vault","secrets","secrets_name_idx","CREATE UNIQUE INDEX secrets_name_idx ON vault.secrets USING btree (name) WHERE (name IS NOT NULL)","null"
"INDEX","vault","secrets","secrets_pkey","CREATE UNIQUE INDEX secrets_pkey ON vault.secrets USING btree (id)","null"
"TABLE","auth","audit_log_entries","null","Auth: Audit trail for user actions.","null"
"TABLE","auth","flow_state","null","stores metadata for pkce logins","null"
"TABLE","auth","identities","null","Auth: Stores identities associated to a user.","null"
"TABLE","auth","instances","null","Auth: Manages users across multiple sites.","null"
"TABLE","auth","mfa_amr_claims","null","auth: stores authenticator method reference claims for multi factor authentication","null"
"TABLE","auth","mfa_challenges","null","auth: stores metadata about challenge requests made","null"
"TABLE","auth","mfa_factors","null","auth: stores metadata about factors","null"
"TABLE","auth","one_time_tokens","null","null","null"
"TABLE","auth","refresh_tokens","null","Auth: Store of tokens used to refresh JWT tokens once they expire.","null"
"TABLE","auth","saml_providers","null","Auth: Manages SAML Identity Provider connections.","null"
"TABLE","auth","saml_relay_states","null","Auth: Contains SAML Relay State information for each Service Provider initiated login.","null"
"TABLE","auth","schema_migrations","null","Auth: Manages updates to the auth system.","null"
"TABLE","auth","sessions","null","Auth: Stores session data associated to a user.","null"
"TABLE","auth","sso_domains","null","Auth: Manages SSO email address domain mapping to an SSO Identity Provider.","null"
"TABLE","auth","sso_providers","null","Auth: Manages SSO identity provider information; see saml_providers for SAML.","null"
"TABLE","auth","users","null","Auth: Stores user login data within a secure schema.","null"
"TABLE","pgsodium","key","null","This table holds metadata for derived keys given a key_id and key_context. The raw key is never stored.","null"
"TABLE","public","comment_votes","null","null","null"
"TABLE","public","comments","null","null","null"
"TABLE","public","conversation_participants","null","null","null"
"TABLE","public","conversations","null","null","null"
"TABLE","public","friendships","null","null","null"
"TABLE","public","group_members","null","null","null"
"TABLE","public","groups","null","null","null"
"TABLE","public","likes","null","null","null"
"TABLE","public","media","null","null","null"
"TABLE","public","messages","null","null","null"
"TABLE","public","notifications","null","null","null"
"TABLE","public","posts","null","null","null"
"TABLE","public","user_hidden_posts","null","null","null"
"TABLE","public","user_saved_posts","null","null","null"
"TABLE","public","users","null","null","null"
"TABLE","realtime","schema_migrations","null","null","null"
"TABLE","realtime","subscription","null","null","null"
"TABLE","storage","buckets","null","null","null"
"TABLE","storage","migrations","null","null","null"
"TABLE","storage","objects","null","null","null"
"TABLE","storage","s3_multipart_uploads","null","null","null"
"TABLE","storage","s3_multipart_uploads_parts","null","null","null"
"TABLE","vault","secrets","null","Table with encrypted `secret` column for storing sensitive information on disk.","null"
"TRIGGER","auth","users","on_auth_user_created","CREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION handle_new_user()","null"
"TRIGGER","pgsodium","key","key_encrypt_secret_trigger_raw_key","CREATE TRIGGER key_encrypt_secret_trigger_raw_key BEFORE INSERT OR UPDATE OF raw_key ON pgsodium.key FOR EACH ROW EXECUTE FUNCTION pgsodium.key_encrypt_secret_raw_key()","null"
"TRIGGER","public","posts","posts_search_update","CREATE TRIGGER posts_search_update BEFORE INSERT OR UPDATE ON public.posts FOR EACH ROW EXECUTE FUNCTION posts_search_update()","null"
"TRIGGER","public","users","on_public_user_deleted","CREATE TRIGGER on_public_user_deleted AFTER DELETE ON public.users FOR EACH ROW EXECUTE FUNCTION handle_user_delete()","null"
"TRIGGER","realtime","subscription","tr_check_filters","CREATE TRIGGER tr_check_filters BEFORE INSERT OR UPDATE ON realtime.subscription FOR EACH ROW EXECUTE FUNCTION realtime.subscription_check_filters()","null"
"TRIGGER","storage","objects","update_objects_updated_at","CREATE TRIGGER update_objects_updated_at BEFORE UPDATE ON storage.objects FOR EACH ROW EXECUTE FUNCTION storage.update_updated_at_column()","null"
"TRIGGER","vault","secrets","secrets_encrypt_secret_trigger_secret","CREATE TRIGGER secrets_encrypt_secret_trigger_secret BEFORE INSERT OR UPDATE OF secret ON vault.secrets FOR EACH ROW EXECUTE FUNCTION vault.secrets_encrypt_secret_secret()","null"
"VIEW","extensions","pg_stat_statements","null"," SELECT pg_stat_statements.userid,
    pg_stat_statements.dbid,
    pg_stat_statements.toplevel,
    pg_stat_statements.queryid,
    pg_stat_statements.query,
    pg_stat_statements.plans,
    pg_stat_statements.total_plan_time,
    pg_stat_statements.min_plan_time,
    pg_stat_statements.max_plan_time,
    pg_stat_statements.mean_plan_time,
    pg_stat_statements.stddev_plan_time,
    pg_stat_statements.calls,
    pg_stat_statements.total_exec_time,
    pg_stat_statements.min_exec_time,
    pg_stat_statements.max_exec_time,
    pg_stat_statements.mean_exec_time,
    pg_stat_statements.stddev_exec_time,
    pg_stat_statements.rows,
    pg_stat_statements.shared_blks_hit,
    pg_stat_statements.shared_blks_read,
    pg_stat_statements.shared_blks_dirtied,
    pg_stat_statements.shared_blks_written,
    pg_stat_statements.local_blks_hit,
    pg_stat_statements.local_blks_read,
    pg_stat_statements.local_blks_dirtied,
    pg_stat_statements.local_blks_written,
    pg_stat_statements.temp_blks_read,
    pg_stat_statements.temp_blks_written,
    pg_stat_statements.blk_read_time,
    pg_stat_statements.blk_write_time,
    pg_stat_statements.temp_blk_read_time,
    pg_stat_statements.temp_blk_write_time,
    pg_stat_statements.wal_records,
    pg_stat_statements.wal_fpi,
    pg_stat_statements.wal_bytes,
    pg_stat_statements.jit_functions,
    pg_stat_statements.jit_generation_time,
    pg_stat_statements.jit_inlining_count,
    pg_stat_statements.jit_inlining_time,
    pg_stat_statements.jit_optimization_count,
    pg_stat_statements.jit_optimization_time,
    pg_stat_statements.jit_emission_count,
    pg_stat_statements.jit_emission_time
   FROM pg_stat_statements(true) pg_stat_statements(userid, dbid, toplevel, queryid, query, plans, total_plan_time, min_plan_time, max_plan_time, mean_plan_time, stddev_plan_time, calls, total_exec_time, min_exec_time, max_exec_time, mean_exec_time, stddev_exec_time, rows, shared_blks_hit, shared_blks_read, shared_blks_dirtied, shared_blks_written, local_blks_hit, local_blks_read, local_blks_dirtied, local_blks_written, temp_blks_read, temp_blks_written, blk_read_time, blk_write_time, temp_blk_read_time, temp_blk_write_time, wal_records, wal_fpi, wal_bytes, jit_functions, jit_generation_time, jit_inlining_count, jit_inlining_time, jit_optimization_count, jit_optimization_time, jit_emission_count, jit_emission_time);","null"
"VIEW","extensions","pg_stat_statements_info","null"," SELECT pg_stat_statements_info.dealloc,
    pg_stat_statements_info.stats_reset
   FROM pg_stat_statements_info() pg_stat_statements_info(dealloc, stats_reset);","null"
"VIEW","pgsodium","decrypted_key","null"," SELECT key.id,
    key.status,
    key.created,
    key.expires,
    key.key_type,
    key.key_id,
    key.key_context,
    key.name,
    key.associated_data,
    key.raw_key,
        CASE
            WHEN (key.raw_key IS NULL) THEN NULL::bytea
            ELSE
            CASE
                WHEN (key.parent_key IS NULL) THEN NULL::bytea
                ELSE pgsodium.crypto_aead_det_decrypt(key.raw_key, convert_to(((key.id)::text || key.associated_data), 'utf8'::name), key.parent_key, key.raw_key_nonce)
            END
        END AS decrypted_raw_key,
    key.raw_key_nonce,
    key.parent_key,
    key.comment
   FROM pgsodium.key;","null"
"VIEW","pgsodium","mask_columns","null"," SELECT a.attname,
    a.attrelid,
    m.key_id,
    m.key_id_column,
    m.associated_columns,
    m.nonce_column,
    m.format_type
   FROM (pg_attribute a
     LEFT JOIN pgsodium.masking_rule m ON (((m.attrelid = a.attrelid) AND (m.attname = a.attname))))
  WHERE ((a.attnum > 0) AND (NOT a.attisdropped))
  ORDER BY a.attnum;","null"
"VIEW","pgsodium","masking_rule","null"," WITH const AS (
         SELECT 'encrypt +with +key +id +([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})'::text AS pattern_key_id,
            'encrypt +with +key +column +([\w\"\-$]+)'::text AS pattern_key_id_column,
            '(?<=associated) +\(([\w\"\-$, ]+)\)'::text AS pattern_associated_columns,
            '(?<=nonce) +([\w\"\-$]+)'::text AS pattern_nonce_column,
            '(?<=decrypt with view) +([\w\"\-$]+\.[\w\"\-$]+)'::text AS pattern_view_name,
            '(?<=security invoker)'::text AS pattern_security_invoker
        ), rules_from_seclabels AS (
         SELECT sl.objoid AS attrelid,
            sl.objsubid AS attnum,
            (c.relnamespace)::regnamespace AS relnamespace,
            c.relname,
            a.attname,
            format_type(a.atttypid, a.atttypmod) AS format_type,
            sl.label AS col_description,
            (regexp_match(sl.label, k.pattern_key_id_column, 'i'::text))[1] AS key_id_column,
            (regexp_match(sl.label, k.pattern_key_id, 'i'::text))[1] AS key_id,
            (regexp_match(sl.label, k.pattern_associated_columns, 'i'::text))[1] AS associated_columns,
            (regexp_match(sl.label, k.pattern_nonce_column, 'i'::text))[1] AS nonce_column,
            COALESCE((regexp_match(sl2.label, k.pattern_view_name, 'i'::text))[1], (((c.relnamespace)::regnamespace || '.'::text) || quote_ident(('decrypted_'::text || (c.relname)::text)))) AS view_name,
            100 AS priority,
            ((regexp_match(sl.label, k.pattern_security_invoker, 'i'::text))[1] IS NOT NULL) AS security_invoker
           FROM const k,
            (((pg_seclabel sl
             JOIN pg_class c ON (((sl.classoid = c.tableoid) AND (sl.objoid = c.oid))))
             JOIN pg_attribute a ON (((a.attrelid = c.oid) AND (sl.objsubid = a.attnum))))
             LEFT JOIN pg_seclabel sl2 ON (((sl2.objoid = c.oid) AND (sl2.objsubid = 0))))
          WHERE ((a.attnum > 0) AND (((c.relnamespace)::regnamespace)::oid <> ('pg_catalog'::regnamespace)::oid) AND (NOT a.attisdropped) AND (sl.label ~~* 'ENCRYPT%'::text) AND (sl.provider = 'pgsodium'::text))
        )
 SELECT DISTINCT ON (rules_from_seclabels.attrelid, rules_from_seclabels.attnum) rules_from_seclabels.attrelid,
    rules_from_seclabels.attnum,
    rules_from_seclabels.relnamespace,
    rules_from_seclabels.relname,
    rules_from_seclabels.attname,
    rules_from_seclabels.format_type,
    rules_from_seclabels.col_description,
    rules_from_seclabels.key_id_column,
    rules_from_seclabels.key_id,
    rules_from_seclabels.associated_columns,
    rules_from_seclabels.nonce_column,
    rules_from_seclabels.view_name,
    rules_from_seclabels.priority,
    rules_from_seclabels.security_invoker
   FROM rules_from_seclabels
  ORDER BY rules_from_seclabels.attrelid, rules_from_seclabels.attnum, rules_from_seclabels.priority DESC;","null"
"VIEW","pgsodium","valid_key","null"," SELECT key.id,
    key.name,
    key.status,
    key.key_type,
    key.key_id,
    key.key_context,
    key.created,
    key.expires,
    key.associated_data
   FROM pgsodium.key
  WHERE ((key.status = ANY (ARRAY['valid'::pgsodium.key_status, 'default'::pgsodium.key_status])) AND
        CASE
            WHEN (key.expires IS NULL) THEN true
            ELSE (key.expires > now())
        END);","null"
"VIEW","public","comment_vote_counts","null"," SELECT comment_votes.comment_id,
    sum(
        CASE
            WHEN (comment_votes.vote_type = 'upvote'::vote_type) THEN 1
            ELSE 0
        END) AS upvotes,
    sum(
        CASE
            WHEN (comment_votes.vote_type = 'downvote'::vote_type) THEN 1
            ELSE 0
        END) AS downvotes,
    sum(
        CASE
            WHEN (comment_votes.vote_type = 'upvote'::vote_type) THEN 1
            ELSE '-1'::integer
        END) AS score
   FROM comment_votes
  GROUP BY comment_votes.comment_id;","null"
"VIEW","public","feed_posts","null"," SELECT p.id,
    p.user_id,
    p.content,
    p.privacy_level,
    p.group_id,
    p.created_at,
    p.updated_at,
    p.search_vector,
    u.username,
    u.avatar_url
   FROM (posts p
     JOIN users u ON ((p.user_id = u.id)))
  WHERE ((p.privacy_level = 'public'::privacy_level) OR ((p.privacy_level = 'friends'::privacy_level) AND (EXISTS ( SELECT 1
           FROM friendships f
          WHERE (((f.user_id = p.user_id) OR (f.friend_id = p.user_id)) AND (f.status = 'accepted'::friendship_status))))));","null"
"VIEW","public","user_profile_posts","null"," SELECT p.id,
    p.user_id,
    p.content,
    p.privacy_level,
    p.group_id,
    p.created_at,
    p.updated_at,
    p.search_vector,
    count(l.id) AS like_count,
    count(c.id) AS comment_count
   FROM ((posts p
     LEFT JOIN likes l ON ((p.id = l.post_id)))
     LEFT JOIN comments c ON ((p.id = c.post_id)))
  GROUP BY p.id;","null"
"VIEW","vault","decrypted_secrets","null"," SELECT secrets.id,
    secrets.name,
    secrets.description,
    secrets.secret,
        CASE
            WHEN (secrets.secret IS NULL) THEN NULL::text
            ELSE
            CASE
                WHEN (secrets.key_id IS NULL) THEN NULL::text
                ELSE convert_from(pgsodium.crypto_aead_det_decrypt(decode(secrets.secret, 'base64'::text), convert_to(((((secrets.id)::text || secrets.description) || (secrets.created_at)::text) || (secrets.updated_at)::text), 'utf8'::name), secrets.key_id, secrets.nonce), 'utf8'::name)
            END
        END AS decrypted_secret,
    secrets.key_id,
    secrets.nonce,
    secrets.created_at,
    secrets.updated_at
   FROM vault.secrets;","null"